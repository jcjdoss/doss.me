<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SatTrack Pro - Ham Radio Satellite Tracker</title>
<link rel="stylesheet" href="https://cesium.com/downloads/cesiumjs/releases/1.126/Build/Cesium/Widgets/widgets.css" />
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg-primary: #0a0e14;
  --bg-secondary: #111820;
  --bg-tertiary: #1a2130;
  --bg-panel: #0f1520;
  --border: #1e2a3a;
  --border-bright: #2d3f55;
  --text-primary: #d4dce8;
  --text-secondary: #7a8ba0;
  --text-muted: #4a5a6e;
  --accent: #4da6ff;
  --accent-dim: #2a5a8f;
  --green: #00e676;
  --green-dim: rgba(0, 230, 118, 0.15);
  --red: #ff5252;
  --red-dim: rgba(255, 82, 82, 0.12);
  --yellow: #ffca28;
  --gold: #ffd54f;
  --gold-dim: rgba(255, 213, 79, 0.15);
  --orange: #ff9100;
  --cyan: #00e5ff;
  --sidebar-width: 420px;
}

html, body { height: 100%; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: var(--bg-primary); color: var(--text-primary); overflow: hidden; font-size: 14px; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
.mono { font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; }

#app { display: flex; height: 100%; flex-direction: column; }

/* Header */
#header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 0 20px; background: var(--bg-secondary); border-bottom: 1px solid var(--border);
  height: 52px; flex-shrink: 0; z-index: 1000;
}
#header-left { display: flex; align-items: center; gap: 16px; }
#header h1 { font-size: 15px; font-weight: 800; letter-spacing: 2px; text-transform: uppercase; }
#header h1 .callsign { color: var(--cyan); }
#header h1 .ver { color: var(--text-muted); font-weight: 500; font-size: 10px; margin-left: 8px; letter-spacing: 1px; }
#my-callsign-badge {
  display: none; align-items: center; gap: 6px; padding: 4px 14px;
  background: rgba(0,229,255,0.08); border: 1px solid rgba(0,229,255,0.2);
  border-radius: 8px; cursor: pointer; transition: all 0.2s;
}
#my-callsign-badge:hover { background: rgba(0,229,255,0.14); border-color: rgba(0,229,255,0.35); }
#my-callsign-badge.visible { display: flex; }
#my-callsign-badge .cs-icon { color: var(--cyan); flex-shrink: 0; }
#my-callsign-badge .cs-call {
  font-size: 16px; font-weight: 800; color: var(--cyan); letter-spacing: 2px;
  font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace;
}
#my-callsign-badge .cs-label { font-size: 8px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; font-weight: 600; }
#header-right { display: flex; align-items: center; gap: 16px; }
#header-divider { width: 1px; height: 24px; background: var(--border); }
#tle-status {
  font-size: 10px; color: var(--green); font-weight: 600; letter-spacing: 1px;
  background: rgba(0,230,118,0.08); padding: 3px 10px; border-radius: 20px; border: 1px solid rgba(0,230,118,0.15);
}
#clock { font-size: 14px; color: var(--accent); letter-spacing: 0.5px; font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-weight: 600; }
.btn-icon {
  display: inline-flex; align-items: center;
  background: var(--bg-tertiary); border: 1px solid var(--border-bright); color: var(--text-secondary);
  border-radius: 8px; padding: 7px 16px; cursor: pointer; font-size: 12px; font-family: inherit;
  transition: all 0.2s; letter-spacing: 0.5px; font-weight: 600;
}
.btn-icon:hover { background: rgba(77,166,255,0.08); color: var(--accent); border-color: var(--accent-dim); }

/* Main content */
#main { display: flex; flex: 1; min-height: 0; }

/* Sidebar */
#sidebar {
  width: var(--sidebar-width); background: var(--bg-secondary); border-right: 1px solid var(--border);
  display: flex; flex-direction: column; overflow: hidden; flex-shrink: 0;
}

.section-header { padding: 10px 18px; font-size: 11px; text-transform: uppercase; letter-spacing: 2px; color: var(--text-muted); background: var(--bg-primary); border-bottom: 1px solid var(--border); font-weight: 700; }

/* Satellite list */
#sat-list { flex: 1; overflow-y: auto; min-height: 0; }
#sat-list::-webkit-scrollbar { width: 4px; }
#sat-list::-webkit-scrollbar-thumb { background: var(--border-bright); border-radius: 2px; }
#sat-list::-webkit-scrollbar-track { background: transparent; }

.sat-category { padding: 10px 18px 6px; font-size: 10px; text-transform: uppercase; letter-spacing: 2px; color: var(--text-muted); font-weight: 700; background: rgba(0,0,0,0.25); }

.sat-item {
  display: flex; align-items: center; gap: 10px; padding: 9px 18px;
  cursor: pointer; transition: all 0.15s; user-select: none; border-left: 3px solid transparent;
}
.sat-item:hover { background: rgba(77, 166, 255, 0.05); }
.sat-item.active { background: rgba(77, 166, 255, 0.08); border-left-color: var(--accent); }
.sat-item input[type="checkbox"] { accent-color: var(--accent); flex-shrink: 0; cursor: pointer; width: 16px; height: 16px; }
.sat-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; box-shadow: 0 0 4px currentColor; }
.sat-item .sat-name { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 13px; font-weight: 600; letter-spacing: 0.2px; }
.sat-item .sat-elev { font-size: 13px; color: var(--text-muted); min-width: 44px; text-align: right; font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-weight: 500; }
.sat-item .sat-elev.above { color: var(--green); font-weight: 700; }
.sat-item .sat-rf-dot { width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0; margin-left: 2px; }
.sat-item .sat-rf-dot.in-range { background: var(--green); box-shadow: 0 0 8px var(--green); }
.sat-item .sat-rf-dot.out-range { background: var(--border-bright); }

/* Details panel */
#details-panel {
  background: var(--bg-panel); border-top: 1px solid var(--border);
  flex-shrink: 0; overflow-y: auto; max-height: 55%;
}
#details-panel::-webkit-scrollbar { width: 4px; }
#details-panel::-webkit-scrollbar-thumb { background: var(--border-bright); border-radius: 2px; }

.detail-header { display: flex; align-items: center; gap: 10px; padding: 14px 18px 8px; }
.detail-header .detail-name-dot { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 0 6px currentColor; }
.detail-header .detail-sat-name { font-size: 17px; font-weight: 800; letter-spacing: 0.3px; }
.detail-header .detail-norad { font-size: 11px; color: var(--text-muted); margin-left: auto; font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-weight: 500; }

/* Satellite craft graphic */
.sat-graphic { display: flex; align-items: center; gap: 14px; padding: 10px 18px; border-bottom: 1px solid var(--border); background: rgba(0,0,0,0.15); }
.sat-craft-svg { flex-shrink: 0; filter: drop-shadow(0 0 6px rgba(77,166,255,0.2)); }
.sat-graphic-info { flex: 1; display: flex; flex-direction: column; gap: 5px; }
.sat-graphic-info .sg-row { display: flex; justify-content: space-between; align-items: baseline; }
.sat-graphic-info .sg-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1.5px; font-weight: 600; }
.sat-graphic-info .sg-value { font-size: 15px; font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-weight: 600; }
.sat-graphic-info .sg-value.above-hz { color: var(--green); }
.sat-graphic-info .sg-value.below-hz { color: var(--red); }

.detail-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0; padding: 2px 18px; }
.detail-row { display: flex; justify-content: space-between; align-items: baseline; padding: 4px 0; border-bottom: 1px solid rgba(30,42,58,0.4); }
.detail-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1.5px; font-weight: 600; }
.detail-value { font-size: 14px; color: var(--text-primary); text-align: right; font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-weight: 500; }

/* Visibility badges */
.vis-row { display: flex; gap: 8px; padding: 10px 18px; flex-wrap: wrap; }
.vis-badge {
  display: flex; align-items: center; gap: 6px; padding: 6px 12px;
  border-radius: 6px; font-size: 11px; font-weight: 700; letter-spacing: 1px; text-transform: uppercase;
  border: 1px solid;
}
.vis-badge.rf-yes { background: var(--green-dim); color: var(--green); border-color: rgba(0,230,118,0.3); }
.vis-badge.rf-no { background: var(--red-dim); color: var(--red); border-color: rgba(255,82,82,0.2); }
.vis-badge.vis-yes { background: var(--gold-dim); color: var(--gold); border-color: rgba(255,213,79,0.3); }
.vis-badge.vis-no { background: rgba(74,90,110,0.15); color: var(--text-muted); border-color: rgba(74,90,110,0.3); }
.vis-dot { width: 6px; height: 6px; border-radius: 50%; }
.vis-badge.rf-yes .vis-dot { background: var(--green); box-shadow: 0 0 8px var(--green); }
.vis-badge.rf-no .vis-dot { background: var(--red); }
.vis-badge.vis-yes .vis-dot { background: var(--gold); box-shadow: 0 0 8px var(--gold); }
.vis-badge.vis-no .vis-dot { background: var(--text-muted); }

/* Frequency & Doppler section */
.freq-section { padding: 8px 18px 10px; border-top: 1px solid var(--border); }
.freq-section-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1.5px; font-weight: 600; margin-bottom: 4px; }
.freq-row { display: flex; justify-content: space-between; align-items: center; padding: 3px 0; }
.freq-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; font-weight: 600; }
.freq-value { font-size: 13px; color: var(--cyan); font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-weight: 600; }
.freq-doppler { font-size: 11px; color: var(--orange); font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-weight: 500; }
.freq-doppler.positive { color: var(--orange); }
.freq-doppler.negative { color: var(--accent); }

/* Doppler shift gauge */
.doppler-gauge-wrap { margin-top: 10px; }
.doppler-gauge-labels { display: flex; justify-content: space-between; font-size: 8px; color: var(--text-muted); letter-spacing: 0.5px; font-family: 'SF Mono', 'Fira Code', monospace; margin-bottom: 3px; opacity: 0.6; }
.doppler-gauge { position: relative; height: 8px; background: var(--bg-tertiary); border-radius: 4px; border: 1px solid var(--border); overflow: visible; }
.doppler-gauge-center { position: absolute; left: 50%; top: -1px; width: 1px; height: 10px; background: rgba(255,255,255,0.15); }
.doppler-gauge-fill {
  position: absolute; top: -1px; width: 10px; height: 10px; border-radius: 50%;
  background: var(--cyan); box-shadow: 0 0 8px var(--cyan), 0 0 3px var(--cyan);
  transform: translateX(-50%); transition: left 0.3s ease;
}
.doppler-direction {
  display: flex; align-items: center; justify-content: center; gap: 6px;
  margin-top: 6px; font-size: 11px; font-weight: 600; letter-spacing: 0.5px; text-transform: uppercase;
}
.doppler-direction.approaching { color: var(--orange); }
.doppler-direction.receding { color: var(--accent); }
.doppler-direction.stationary { color: var(--green); }
.dir-arrow { font-size: 9px; letter-spacing: -2px; animation: pulse-arrow 1s ease-in-out infinite; }
.dir-rate { font-family: 'SF Mono', 'Fira Code', monospace; font-size: 11px; }
@keyframes pulse-arrow { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }

/* Doppler S-curve chart */
.doppler-chart-wrap { margin-top: 10px; }
.doppler-chart-label { font-size: 9px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; font-weight: 600; margin-bottom: 4px; }
.doppler-chart { width: 100%; height: 80px; border-radius: 6px; background: var(--bg-tertiary); border: 1px solid var(--border); display: block; }
.doppler-chart-times { display: flex; justify-content: space-between; margin-top: 2px; font-size: 9px; color: var(--text-muted); font-family: 'SF Mono', 'Fira Code', monospace; opacity: 0.6; }

/* Signal meter */
.signal-meter { padding: 8px 18px 10px; border-top: 1px solid var(--border); }
.signal-meter-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1.5px; font-weight: 600; margin-bottom: 6px; }
.signal-bar-container { display: flex; gap: 3px; height: 18px; align-items: flex-end; }
.signal-bar {
  width: 8px; border-radius: 2px; transition: height 0.3s, background 0.3s;
  background: var(--border);
}
.signal-bar.active.s1 { background: var(--green); height: 4px; }
.signal-bar.active.s2 { background: var(--green); height: 6px; }
.signal-bar.active.s3 { background: var(--green); height: 8px; }
.signal-bar.active.s4 { background: var(--green); height: 10px; }
.signal-bar.active.s5 { background: var(--yellow); height: 11px; }
.signal-bar.active.s6 { background: var(--yellow); height: 13px; }
.signal-bar.active.s7 { background: var(--orange); height: 14px; }
.signal-bar.active.s8 { background: var(--orange); height: 16px; }
.signal-bar.active.s9 { background: var(--red); height: 18px; }
.signal-bar:not(.active) { height: 4px; }
.signal-value { font-size: 13px; margin-left: 8px; color: var(--text-secondary); font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-weight: 700; }

/* Azimuth compass */
.compass-section { padding: 10px 18px; display: flex; gap: 16px; align-items: center; border-top: 1px solid var(--border); }
.compass-section-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1.5px; font-weight: 600; margin-bottom: 6px; }
.compass-container { position: relative; width: 80px; height: 80px; flex-shrink: 0; }
.compass-ring {
  width: 80px; height: 80px; border-radius: 50%; border: 2px solid var(--border-bright);
  position: relative; background: radial-gradient(circle, var(--bg-tertiary) 0%, var(--bg-primary) 100%);
}
.compass-cardinal {
  position: absolute; font-size: 9px; font-weight: 800; color: var(--text-muted); letter-spacing: 0.5px;
}
.compass-n { top: 2px; left: 50%; transform: translateX(-50%); color: var(--red); }
.compass-s { bottom: 2px; left: 50%; transform: translateX(-50%); }
.compass-e { right: 3px; top: 50%; transform: translateY(-50%); }
.compass-w { left: 3px; top: 50%; transform: translateY(-50%); }
.compass-needle {
  position: absolute; top: 50%; left: 50%; width: 2px; height: 32px;
  transform-origin: bottom center; border-radius: 1px;
  background: linear-gradient(to top, var(--accent), var(--cyan));
  box-shadow: 0 0 8px var(--accent);
  transition: transform 0.5s ease-out;
}
.compass-center { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 7px; height: 7px; border-radius: 50%; background: var(--accent); border: 1.5px solid #fff; z-index: 1; }
.compass-data { flex: 1; }
.compass-data .cd-row { display: flex; justify-content: space-between; align-items: baseline; padding: 2px 0; }
.compass-data .cd-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1.5px; font-weight: 600; }
.compass-data .cd-value { font-size: 14px; font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-weight: 600; }

/* Next pass / AOS-LOS */
.pass-section { padding: 10px 18px; border-top: 1px solid var(--border); }
.pass-title { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1.5px; font-weight: 600; margin-bottom: 6px; }
.pass-info { display: flex; gap: 8px; flex-wrap: wrap; }
.pass-chip {
  padding: 5px 10px; border-radius: 6px; font-size: 12px;
  background: var(--bg-tertiary); border: 1px solid var(--border);
}
.pass-chip .pc-label { color: var(--text-muted); font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; }
.pass-chip .pc-value { color: var(--accent); font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-weight: 600; }
.pass-chip .pc-value.urgent { color: var(--green); }
.pass-quality { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: 700; letter-spacing: 0.5px; text-transform: uppercase; margin-left: 4px; }
.pass-quality.excellent { background: rgba(0,230,118,0.2); color: var(--green); }
.pass-quality.good { background: rgba(255,202,40,0.2); color: var(--yellow); }
.pass-quality.fair { background: rgba(255,145,0,0.2); color: var(--orange); }
.pass-quality.poor { background: rgba(255,82,82,0.15); color: var(--red); }

.pass-count { float: right; font-size: 9px; color: var(--text-muted); letter-spacing: 0.5px; font-weight: 500; opacity: 0.7; }
.pass-table-wrap { margin-top: 10px; max-height: 220px; overflow-y: auto; border-radius: 8px; border: 1px solid var(--border); }
.pass-table-wrap::-webkit-scrollbar { width: 4px; }
.pass-table-wrap::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
.pass-table { width: 100%; border-collapse: collapse; font-size: 11px; }
.pass-table thead { position: sticky; top: 0; z-index: 1; }
.pass-table th {
  background: var(--bg-tertiary); color: var(--text-muted); font-size: 9px; font-weight: 600;
  text-transform: uppercase; letter-spacing: 0.8px; padding: 6px 6px; text-align: left;
  border-bottom: 1px solid var(--border);
}
.pass-table td { padding: 6px 6px; border-bottom: 1px solid rgba(255,255,255,0.03); vertical-align: middle; }
.pass-table .pass-num { color: var(--text-muted); font-size: 10px; font-weight: 600; width: 20px; text-align: center; }
.pass-table .pass-time { font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-size: 10px; color: var(--text-secondary); white-space: nowrap; }
.pass-table .pass-hms { color: var(--accent); font-weight: 600; font-size: 11px; }
.pass-table .pass-az { color: var(--text-secondary); font-size: 11px; font-weight: 500; }
.pass-table .pass-el { white-space: nowrap; }
.pass-table .pass-dir { color: var(--text-muted); font-size: 9px; }
.pass-table .pass-dur { font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; color: var(--text-secondary); font-size: 10px; font-weight: 500; white-space: nowrap; }
.pass-row.active { background: rgba(0,230,118,0.08); }
.pass-row.active .pass-hms { color: var(--green); }
.pass-row.past { opacity: 0.35; }
.pass-row:hover { background: rgba(255,255,255,0.03); }

.no-selection { color: var(--text-muted); font-size: 13px; padding: 30px 18px; text-align: center; letter-spacing: 1px; font-weight: 500; }

/* Map / Cesium container */
#map-container { flex: 1; position: relative; }
#cesiumContainer { width: 100%; height: 100%; background: var(--bg-primary); }

/* Cesium dark-theme overrides */
.cesium-viewer-bottom { display: none !important; }
.cesium-viewer .cesium-widget-credits { display: none !important; }
.cesium-viewer-toolbar { position: absolute; top: 8px; right: 8px; }
.cesium-button { background: var(--bg-secondary) !important; border: 1px solid var(--border) !important; color: var(--text-primary) !important; border-radius: 4px !important; }
.cesium-button:hover { background: var(--bg-tertiary) !important; border-color: var(--accent-dim) !important; }
.cesium-viewer-geocoderContainer { display: none !important; }
.cesium-viewer-animationContainer { display: none !important; }
.cesium-viewer-timelineContainer { display: none !important; }
.cesium-viewer-fullscreenContainer { display: none !important; }
.cesium-infoBox { display: none !important; }
.cesium-selection-wrapper { display: none !important; }
.cesium-baseLayerPicker-dropDown { background: var(--bg-secondary) !important; border: 1px solid var(--border-bright) !important; border-radius: 6px !important; }
.cesium-baseLayerPicker-itemLabel { color: var(--text-primary) !important; font-family: inherit !important; font-size: 11px !important; }
.cesium-baseLayerPicker-sectionTitle { color: var(--text-muted) !important; font-family: inherit !important; }
.cesium-navigation-help { display: none !important; }
.cesium-navigationHelpButton-wrapper { display: none !important; }

/* Map overlay: station locator card (clickable) */
#grid-overlay {
  position: absolute; top: 12px; left: 50%; transform: translateX(-50%); z-index: 999;
  background: rgba(10, 14, 20, 0.92); border: 1px solid var(--border-bright);
  border-radius: 10px; padding: 8px 18px; cursor: pointer; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  display: flex; align-items: center; gap: 10px; transition: all 0.2s;
  box-shadow: 0 4px 16px rgba(0,0,0,0.3);
}
#grid-overlay:hover { border-color: var(--accent-dim); background: rgba(10, 14, 20, 0.96); transform: translateX(-50%) scale(1.02); }
#grid-overlay .grid-pin { color: var(--accent); flex-shrink: 0; }
#grid-overlay .grid-info { display: flex; flex-direction: column; gap: 1px; }
#grid-overlay .grid-value { color: var(--cyan); font-size: 18px; font-weight: 800; letter-spacing: 2px; font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; line-height: 1; }
#grid-overlay .grid-subtitle { color: var(--text-muted); font-size: 9px; font-weight: 500; letter-spacing: 0; }

/* Track button */
.btn-track { background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-muted); border-radius: 5px; padding: 3px 10px; cursor: pointer; font-size: 10px; font-family: inherit; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s; font-weight: 700; }
.btn-track:hover { color: var(--accent); border-color: var(--accent-dim); }
.btn-track.active { color: var(--cyan); border-color: var(--cyan); background: rgba(0,229,255,0.1); box-shadow: 0 0 8px rgba(0,229,255,0.2); }

/* LOS line legend */
#los-legend {
  position: absolute; bottom: 12px; right: 12px; z-index: 999;
  background: rgba(10, 14, 20, 0.9); border: 1px solid var(--border-bright);
  border-radius: 6px; padding: 6px 12px; font-size: 10px; pointer-events: none; display: none; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
}
#los-legend .los-label { color: var(--green); text-transform: uppercase; letter-spacing: 1px; font-weight: 600; }

/* Floating map layer panel */
#map-layers-panel {
  position: absolute; top: 12px; right: 12px; z-index: 999;
  display: flex; flex-direction: column; gap: 6px; align-items: flex-end;
}
#map-layers-toggle {
  background: rgba(10, 14, 20, 0.9); border: 1px solid var(--border-bright);
  border-radius: 8px; padding: 7px 14px; cursor: pointer; font-size: 11px;
  font-family: inherit; color: var(--text-secondary); text-transform: uppercase;
  letter-spacing: 1.5px; transition: all 0.2s; font-weight: 700; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
}
#map-layers-toggle:hover { color: var(--accent); border-color: var(--accent-dim); }
#map-layers-toggle.open { color: var(--accent); border-color: var(--accent-dim); background: rgba(10, 14, 20, 0.95); }
#map-layers-drawer {
  display: none; background: rgba(10, 14, 20, 0.95); border: 1px solid var(--border-bright);
  border-radius: 10px; padding: 12px; min-width: 220px; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
}
#map-layers-drawer.open { display: block; }
.layer-section-title {
  font-size: 9px; text-transform: uppercase; letter-spacing: 2px; color: var(--text-muted);
  margin-top: 10px; margin-bottom: 4px; padding-bottom: 4px; border-bottom: 1px solid var(--border); font-weight: 700;
}
.layer-section-title:first-child { margin-top: 0; }
.layer-btn {
  display: flex; align-items: center; gap: 8px; width: 100%; padding: 5px 6px;
  background: none; border: none; cursor: pointer; font-family: inherit;
  font-size: 12px; color: var(--text-secondary); border-radius: 5px; transition: all 0.15s; font-weight: 500;
}
.layer-btn:hover { background: rgba(77, 166, 255, 0.06); }
.layer-btn.active { color: var(--accent); font-weight: 600; }
.layer-btn .layer-dot {
  width: 8px; height: 8px; border-radius: 50%; border: 1.5px solid var(--border-bright);
  flex-shrink: 0; transition: all 0.15s;
}
.layer-btn.active .layer-dot { background: var(--accent); border-color: var(--accent); box-shadow: 0 0 6px var(--accent); }
.layer-btn .layer-label { flex: 1; text-align: left; }
.layer-btn .layer-key { font-size: 9px; color: var(--text-muted); font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-weight: 600; background: rgba(255,255,255,0.05); padding: 1px 5px; border-radius: 3px; }

/* Bottom bar */
#bottom-bar {
  display: flex; align-items: center; justify-content: space-between;
  padding: 0 12px; background: var(--bg-secondary); border-top: 1px solid var(--border);
  height: 42px; flex-shrink: 0; z-index: 1000;
}
#observer-info { display: flex; align-items: center; gap: 8px; }
#qth-card {
  display: flex; align-items: center; gap: 8px; padding: 4px 12px; border-radius: 8px;
  cursor: pointer; transition: all 0.2s; border: 1px solid transparent;
}
#qth-card:hover { background: rgba(77,166,255,0.06); border-color: var(--accent-dim); }
#qth-card .qth-pin { color: var(--accent); flex-shrink: 0; }
#qth-card .qth-details { display: flex; flex-direction: column; gap: 0; }
#qth-card .qth-primary { display: flex; align-items: center; gap: 8px; }
#observer-coords { color: var(--text-secondary); font-size: 11px; font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-weight: 500; }
#observer-grid { color: var(--cyan); font-weight: 700; font-size: 13px; font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; letter-spacing: 1px; }
#qth-card .qth-secondary { font-size: 9px; color: var(--text-muted); font-weight: 500; line-height: 1; }
.btn-sm {
  background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-muted);
  border-radius: 5px; padding: 3px 10px; cursor: pointer; font-size: 10px; font-family: inherit;
  text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s; font-weight: 700;
}
.btn-sm:hover { color: var(--accent); border-color: var(--accent-dim); }
#tracking-stats { color: var(--text-muted); font-size: 12px; display: flex; gap: 16px; font-weight: 500; }
#tracking-stats .stat-label { color: var(--text-muted); font-size: 10px; text-transform: uppercase; letter-spacing: 1px; font-weight: 600; }
#tracking-stats .stat-value { color: var(--text-secondary); font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; font-weight: 600; }
#tracking-stats .stat-value.highlight { color: var(--green); }

/* Radio indicator in bottom bar */
.radio-ind {
  display: flex; align-items: center; gap: 6px; padding: 3px 10px;
  background: rgba(0,230,118,0.08); border: 1px solid rgba(0,230,118,0.2);
  border-radius: 6px; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px;
}
.radio-ind.disconnected { background: rgba(255,82,82,0.08); border-color: rgba(255,82,82,0.2); }
.radio-ind-dot {
  width: 6px; height: 6px; border-radius: 50%; background: var(--green);
  box-shadow: 0 0 6px var(--green); animation: pulse-arrow 1.5s ease-in-out infinite;
}
.radio-ind.disconnected .radio-ind-dot { background: var(--red); box-shadow: 0 0 6px var(--red); }
.radio-ind-label { color: var(--green); }
.radio-ind.disconnected .radio-ind-label { color: var(--red); }
.radio-ind-freq {
  color: var(--cyan); font-size: 11px; font-weight: 600;
}
.radio-tuned-badge {
  display: flex; align-items: center; gap: 6px; padding: 6px 12px; margin: 4px 18px 0;
  background: rgba(0,230,118,0.08); border: 1px solid rgba(0,230,118,0.2);
  border-radius: 6px; font-size: 10px; font-weight: 700; color: var(--green);
  letter-spacing: 0.8px; text-transform: uppercase;
}
.radio-tuned-badge .radio-dot { width: 5px; height: 5px; border-radius: 50%; background: var(--green); box-shadow: 0 0 6px var(--green); flex-shrink: 0; }

/* Modals */
.modal-overlay {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.75); z-index: 2000; display: flex;
  align-items: center; justify-content: center; backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);
}
.modal-overlay.hidden { display: none; }
.modal {
  background: var(--bg-secondary); border: 1px solid var(--border-bright); border-radius: 12px;
  padding: 24px; width: 380px; max-width: 90vw; box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}
.modal h3 { font-size: 14px; margin-bottom: 16px; text-transform: uppercase; letter-spacing: 2px; font-weight: 800; }
.modal label { font-size: 10px; color: var(--text-muted); display: block; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 1.5px; font-weight: 600; }
.modal input, .modal select {
  width: 100%; padding: 8px 12px; background: var(--bg-primary); border: 1px solid var(--border);
  border-radius: 6px; color: var(--text-primary); font-size: 14px; margin-bottom: 12px; font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace;
}
.modal input:focus, .modal select:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 2px rgba(77,166,255,0.15); }
.modal-buttons { display: flex; gap: 8px; margin-top: 10px; }
.modal-buttons button { flex: 1; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 700; font-family: inherit; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s; }
.btn-primary { background: var(--accent); color: #fff; border: none; }
.btn-primary:hover { filter: brightness(1.15); }
.btn-cancel { background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border); }
.btn-cancel:hover { background: var(--border); }

/* Location modal — Station Profile */
.location-search-wrap {
  position: relative; margin-bottom: 16px;
}
.location-search-wrap input#input-location-search {
  padding: 12px 16px 12px 42px; font-size: 15px; font-family: inherit; font-weight: 500;
  background: var(--bg-primary); border: 2px solid var(--accent-dim);
  border-radius: 10px; color: var(--text-primary); width: 100%;
  transition: border-color 0.2s, box-shadow 0.2s;
}
.location-search-wrap input#input-location-search:focus {
  border-color: var(--accent); box-shadow: 0 0 0 3px rgba(77,166,255,0.2);
  outline: none;
}
.location-search-wrap input#input-location-search::placeholder {
  color: var(--text-muted); font-weight: 400; font-size: 13px;
}
.location-search-wrap .search-icon {
  position: absolute; left: 14px; top: 50%; transform: translateY(-50%);
  color: var(--accent); pointer-events: none;
}
.location-search-hint {
  font-size: 10px; color: var(--text-muted); margin-top: 4px; text-align: center;
  font-weight: 400; letter-spacing: 0;
}
/* Callsign input in modal */
.callsign-row {
  display: flex; align-items: flex-end; gap: 10px; margin-bottom: 16px;
}
.callsign-row .callsign-input-wrap { flex: 1; }
.callsign-row .callsign-input-wrap label { font-size: 9px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1.5px; font-weight: 700; margin-bottom: 4px; display: block; }
.callsign-row input#input-callsign {
  width: 100%; padding: 10px 14px; font-size: 18px; font-weight: 800; letter-spacing: 3px;
  text-transform: uppercase; background: var(--bg-primary); border: 1px solid var(--border-bright);
  border-radius: 8px; color: var(--cyan); font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace;
}
.callsign-row input#input-callsign:focus { outline: none; border-color: var(--cyan); box-shadow: 0 0 0 2px rgba(0,229,255,0.15); }
.callsign-row input#input-callsign::placeholder { color: var(--text-muted); font-weight: 400; font-size: 13px; letter-spacing: 1px; }
.callsign-detected {
  font-size: 10px; color: var(--text-muted); margin-top: 3px; font-weight: 400;
}
.callsign-detected .cd-match { color: var(--green); font-weight: 600; }
#location-results {
  position: absolute; top: 100%; left: 0; right: 0; z-index: 10; margin-top: 4px;
  background: var(--bg-secondary); border: 1px solid var(--border-bright); border-radius: 10px;
  max-height: 220px; overflow-y: auto; display: none; box-shadow: 0 12px 36px rgba(0,0,0,0.5);
}
#location-results .loc-result {
  padding: 10px 14px; cursor: pointer; font-size: 13px; color: var(--text-secondary);
  border-bottom: 1px solid var(--border); transition: all 0.15s;
}
#location-results .loc-result:last-child { border-bottom: none; }
#location-results .loc-result:hover { background: rgba(77,166,255,0.1); color: var(--text-primary); }
#location-results .loc-result .loc-name { font-weight: 600; color: var(--text-primary); font-size: 13px; }
#location-results .loc-result .loc-detail { font-size: 11px; color: var(--text-muted); margin-top: 2px; }

.derived-data {
  display: grid; grid-template-columns: 1fr 1fr; gap: 0; margin-top: 12px;
  border: 1px solid var(--border); border-radius: 8px; overflow: hidden;
}
.derived-item {
  padding: 8px 12px; border-bottom: 1px solid var(--border); background: var(--bg-primary);
}
.derived-item:nth-child(odd) { border-right: 1px solid var(--border); }
.derived-item .derived-label {
  font-size: 9px; text-transform: uppercase; letter-spacing: 1.5px; color: var(--text-muted); font-weight: 600; margin-bottom: 2px;
}
.derived-item .derived-value {
  font-size: 13px; color: var(--cyan); font-weight: 700; font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace;
}
.derived-item .derived-value.text-val { font-family: inherit; color: var(--text-primary); }
.derived-item.full-width { grid-column: 1 / -1; border-right: none; }

.coord-row { display: flex; gap: 8px; }
.coord-row > div { flex: 1; }
.coord-row label { font-size: 9px; }
.coord-row input { font-size: 12px; padding: 6px 8px; }

.loc-section-label {
  font-size: 9px; text-transform: uppercase; letter-spacing: 2px; color: var(--text-muted);
  font-weight: 700; margin-top: 14px; margin-bottom: 6px; padding-bottom: 4px;
}

/* Settings */
.settings-section-label {
  font-size: 10px; text-transform: uppercase; letter-spacing: 2px; color: var(--text-muted);
  font-weight: 700; margin-top: 16px; margin-bottom: 8px; padding-bottom: 6px;
  border-bottom: 1px solid var(--border);
}
.settings-section-label:first-of-type { margin-top: 4px; }
.settings-grid { display: grid; gap: 12px; }
.settings-row { display: flex; align-items: center; justify-content: space-between; }
.settings-row > label { font-size: 13px; color: var(--text-secondary); font-weight: 500; }
.settings-label-group { display: flex; flex-direction: column; gap: 2px; }
.settings-label-group label { font-size: 13px; color: var(--text-secondary); font-weight: 500; margin-bottom: 0; }
.settings-hint { font-size: 10px; color: var(--text-muted); font-weight: 400; }
.settings-input-wrap { display: flex; align-items: center; gap: 4px; }
.settings-input-wrap input { width: 70px; margin-bottom: 0; text-align: center; font-size: 14px; }
.settings-unit { font-size: 12px; color: var(--text-muted); font-weight: 500; }
.settings-row input, .settings-row select { width: 140px; margin-bottom: 0; font-size: 13px; }

/* Toggle switch */
.toggle { position: relative; display: inline-block; width: 40px; height: 22px; flex-shrink: 0; cursor: pointer; margin-bottom: 0 !important; }
.toggle input { opacity: 0; width: 0; height: 0; }
.toggle-slider {
  position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
  background: var(--border-bright); border-radius: 22px; transition: all 0.25s;
}
.toggle-slider::before {
  content: ''; position: absolute; height: 16px; width: 16px; left: 3px; bottom: 3px;
  background: var(--text-muted); border-radius: 50%; transition: all 0.25s;
}
.toggle input:checked + .toggle-slider { background: var(--accent); }
.toggle input:checked + .toggle-slider::before { transform: translateX(18px); background: white; }

/* Loading */
#loading-overlay {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: var(--bg-primary); z-index: 3000;
  display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 16px;
}
#loading-overlay.hidden { display: none; }
.spinner { width: 28px; height: 28px; border: 2px solid var(--border); border-top-color: var(--cyan); border-radius: 50%; animation: spin 0.7s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }
#loading-text { font-size: 12px; color: var(--text-secondary); letter-spacing: 1.5px; text-transform: uppercase; font-weight: 600; }

/* Responsive */
@media (max-width: 768px) {
  #sidebar { width: 100%; height: 40%; border-right: none; border-bottom: 1px solid var(--border); }
  #main { flex-direction: column; }
  :root { --sidebar-width: 100%; }
}
</style>
</head>
<body>
<div id="app">
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div id="loading-text">ACQUIRING SATELLITE DATA...</div>
  </div>

  <div id="header">
    <div id="header-left">
      <h1><span class="callsign">SAT</span>TRACK<span class="ver">v3.0</span></h1>
      <div id="my-callsign-badge" title="Your callsign — click to edit">
        <span class="cs-icon"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg></span>
        <span class="cs-call" id="header-callsign"></span>
      </div>
    </div>
    <div id="header-right">
      <span id="tle-status"></span>
      <span id="header-divider"></span>
      <span id="clock"></span>
      <button class="btn-icon" id="btn-settings"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:-2px;margin-right:5px;"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>Settings</button>
    </div>
  </div>

  <div id="main">
    <div id="sidebar">
      <div class="section-header">Satellite Constellation</div>
      <div id="sat-list"></div>
      <div class="section-header">Telemetry</div>
      <div id="details-panel">
        <div class="no-selection">SELECT A BIRD TO VIEW TELEMETRY</div>
      </div>
    </div>
    <div id="map-container">
      <div id="cesiumContainer"></div>
      <div id="grid-overlay" title="Click to edit your station profile">
        <span class="grid-pin"><svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5a2.5 2.5 0 0 1 0-5 2.5 2.5 0 0 1 0 5z"/></svg></span>
        <div class="grid-info">
          <div class="grid-value" id="observer-grid-map">--</div>
          <div class="grid-subtitle" id="observer-place-label">Click to set your location</div>
        </div>
      </div>
      <div id="los-legend"><span class="los-label">LOS LINE ACTIVE</span></div>
      <div id="map-layers-panel">
        <button id="map-layers-toggle">LAYERS</button>
        <div id="map-layers-drawer">
          <div class="layer-section-title">Base Map</div>
          <button class="layer-btn active" data-basemap="dark"><span class="layer-dot"></span><span class="layer-label">Dark</span></button>
          <button class="layer-btn" data-basemap="dark-labels"><span class="layer-dot"></span><span class="layer-label">Dark + Labels</span></button>
          <button class="layer-btn" data-basemap="satellite"><span class="layer-dot"></span><span class="layer-label">Satellite (ESRI)</span></button>
          <button class="layer-btn" data-basemap="terrain"><span class="layer-dot"></span><span class="layer-label">Terrain</span></button>

          <div class="layer-section-title">Ham Radio</div>
          <button class="layer-btn" data-overlay="gridsquares"><span class="layer-dot"></span><span class="layer-label">Grid Squares</span><span class="layer-key">G</span></button>
          <button class="layer-btn" data-overlay="muf"><span class="layer-dot"></span><span class="layer-label">MUF / Propagation</span><span class="layer-key">M</span></button>
          <button class="layer-btn" data-overlay="grayline"><span class="layer-dot"></span><span class="layer-label">Gray Line</span><span class="layer-key">Y</span></button>

          <div class="layer-section-title">Weather / Overlays</div>
          <button class="layer-btn" data-overlay="radar"><span class="layer-dot"></span><span class="layer-label">Precip Radar</span><span class="layer-key">R</span></button>
          <button class="layer-btn" data-overlay="aurora"><span class="layer-dot"></span><span class="layer-label">Aurora Forecast</span><span class="layer-key">A</span></button>
          <button class="layer-btn" data-overlay="labels"><span class="layer-dot"></span><span class="layer-label">Map Labels</span><span class="layer-key">L</span></button>
          <button class="layer-btn" data-overlay="nautical"><span class="layer-dot"></span><span class="layer-label">Nautical Charts</span><span class="layer-key">N</span></button>
          <button class="layer-btn" data-overlay="terminator"><span class="layer-dot active"></span><span class="layer-label">Day/Night</span><span class="layer-key">D</span></button>
        </div>
      </div>
    </div>
  </div>

  <div id="bottom-bar">
    <div id="observer-info">
      <div id="qth-card" title="Click to edit your station profile">
        <span class="qth-pin"><svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5a2.5 2.5 0 0 1 0-5 2.5 2.5 0 0 1 0 5z"/></svg></span>
        <div class="qth-details">
          <div class="qth-primary">
            <span id="observer-grid" title="Maidenhead Grid Locator">--</span>
            <span id="observer-coords">--</span>
            <span id="observer-zones" style="color:var(--text-muted);font-size:10px;font-weight:500;" title="ITU Zone / CQ Zone"></span>
          </div>
          <div class="qth-secondary" id="qth-place-hint">Click to set your station location</div>
        </div>
      </div>
      <button class="btn-sm" id="btn-gps">GPS</button>
      <button class="btn-track" id="btn-track">TRACK</button>
      <div id="radio-indicator" class="radio-ind" style="display:none;">
        <span class="radio-ind-dot"></span>
        <span class="radio-ind-label">RADIO</span>
        <span class="radio-ind-freq mono" id="radio-ind-freq"></span>
      </div>
    </div>
    <div id="tracking-stats"></div>
  </div>
</div>

<div class="modal-overlay hidden" id="location-modal">
  <div class="modal" style="width:460px;">
    <h3>Station Profile</h3>

    <div class="callsign-row">
      <div class="callsign-input-wrap">
        <label>Your Callsign</label>
        <input type="text" id="input-callsign" placeholder="e.g. W1AW" autocomplete="off" maxlength="10">
        <div class="callsign-detected" id="callsign-detected"></div>
      </div>
    </div>

    <div class="location-search-wrap">
      <span class="search-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></span>
      <input type="text" id="input-location-search" placeholder="Search city, address, or ZIP code..." autocomplete="off">
      <div id="location-results"></div>
    </div>
    <div class="location-search-hint">Type to search — results auto-populate coordinates and ham radio data below</div>

    <div class="loc-section-label">Coordinates <span style="font-weight:400;letter-spacing:0;text-transform:none;font-size:9px;color:var(--text-muted);">— or enter manually</span></div>
    <div class="coord-row">
      <div><label>Latitude</label><input type="number" id="input-lat" step="0.0001" min="-90" max="90" placeholder="39.7392"></div>
      <div><label>Longitude</label><input type="number" id="input-lon" step="0.0001" min="-180" max="180" placeholder="-104.9903"></div>
      <div><label>Altitude (m)</label><input type="number" id="input-alt" step="1" min="0" placeholder="0"></div>
    </div>

    <div class="loc-section-label">Ham Radio Data</div>
    <div class="derived-data" id="derived-data">
      <div class="derived-item"><div class="derived-label">Grid Locator</div><div class="derived-value" id="derived-grid">--</div></div>
      <div class="derived-item"><div class="derived-label">ITU Zone</div><div class="derived-value" id="derived-itu">--</div></div>
      <div class="derived-item"><div class="derived-label">CQ Zone</div><div class="derived-value" id="derived-cq">--</div></div>
      <div class="derived-item"><div class="derived-label">ITU Region</div><div class="derived-value" id="derived-region">--</div></div>
      <div class="derived-item"><div class="derived-label">DXCC Entity</div><div class="derived-value text-val" id="derived-dxcc">--</div></div>
      <div class="derived-item"><div class="derived-label">Callsign Prefix</div><div class="derived-value" id="derived-prefix">--</div></div>
      <div class="derived-item"><div class="derived-label">UTC Offset</div><div class="derived-value" id="derived-utc">--</div></div>
      <div class="derived-item"><div class="derived-label">Sunrise / Sunset</div><div class="derived-value" id="derived-sun">--</div></div>
    </div>

    <div class="modal-buttons" style="margin-top:16px;">
      <button class="btn-cancel" id="btn-loc-cancel">Cancel</button>
      <button class="btn-primary" id="btn-loc-save">Save Location</button>
    </div>
  </div>
</div>

<div class="modal-overlay hidden" id="settings-modal">
  <div class="modal" style="width:480px;">
    <h3>Settings</h3>

    <div class="settings-section-label">Tracking</div>
    <div class="settings-grid">
      <div class="settings-row">
        <div class="settings-label-group"><label>Minimum Elevation</label><span class="settings-hint">Degrees above horizon for RF contact</span></div>
        <div class="settings-input-wrap"><input type="number" id="setting-min-elev" value="5" min="0" max="90" step="1"><span class="settings-unit">&deg;</span></div>
      </div>
      <div class="settings-row">
        <div class="settings-label-group"><label>Refresh Rate</label><span class="settings-hint">How often positions update</span></div>
        <select id="setting-interval"><option value="500">Fast (500ms)</option><option value="1000" selected>Normal (1s)</option><option value="2000">Slow (2s)</option></select>
      </div>
    </div>

    <div class="settings-section-label">Map</div>
    <div class="settings-grid">
      <div class="settings-row">
        <div class="settings-label-group"><label>Base Map Style</label></div>
        <select id="setting-basemap">
          <option value="dark">Dark</option>
          <option value="dark-labels">Dark + Labels</option>
          <option value="satellite">Satellite Imagery</option>
          <option value="terrain">Terrain</option>
        </select>
      </div>
    </div>

    <div class="settings-section-label">Map Overlays</div>
    <div class="settings-grid">
      <div class="settings-row"><label>Precipitation Radar</label><label class="toggle"><input type="checkbox" id="overlay-radar"><span class="toggle-slider"></span></label></div>
      <div class="settings-row"><label>Aurora Forecast</label><label class="toggle"><input type="checkbox" id="overlay-aurora"><span class="toggle-slider"></span></label></div>
      <div class="settings-row"><label>Map Labels</label><label class="toggle"><input type="checkbox" id="overlay-labels"><span class="toggle-slider"></span></label></div>
      <div class="settings-row"><label>Nautical Charts</label><label class="toggle"><input type="checkbox" id="overlay-nautical"><span class="toggle-slider"></span></label></div>
    </div>

    <div class="settings-section-label">Radio Control (CAT)</div>
    <div class="settings-grid" id="radio-settings">
      <div class="settings-row">
        <div class="settings-label-group"><label>Radio Type</label><span class="settings-hint">WebSerial (USB) or rigctld (network)</span></div>
        <select id="setting-radio-brand">
          <option value="none">Disabled</option>
          <option value="kenwood">Kenwood / Elecraft</option>
          <option value="icom">Icom</option>
          <option value="yaesu">Yaesu</option>
          <option value="rigctld">rigctld (Hamlib)</option>
        </select>
      </div>
      <div class="settings-row radio-model-row" style="display:none;">
        <div class="settings-label-group"><label>Model</label></div>
        <select id="setting-radio-model"></select>
      </div>
      <div class="settings-row radio-serial-row" style="display:none;">
        <div class="settings-label-group"><label>Baud Rate</label></div>
        <select id="setting-radio-baud">
          <option value="4800">4800</option>
          <option value="9600" selected>9600</option>
          <option value="19200">19200</option>
          <option value="38400">38400</option>
          <option value="115200">115200</option>
        </select>
      </div>
      <div class="settings-row radio-rigctld-row" style="display:none;">
        <div class="settings-label-group"><label>WebSocket Port</label><span class="settings-hint">Bridge to rigctld TCP daemon</span></div>
        <div class="settings-input-wrap"><input type="number" id="setting-rigctld-port" value="4533" min="1024" max="65535"></div>
      </div>
      <div class="settings-row"><label>Doppler Correction</label><label class="toggle"><input type="checkbox" id="setting-radio-doppler" checked><span class="toggle-slider"></span></label></div>
      <div class="settings-row"><label>Auto-Tune on Select</label><label class="toggle"><input type="checkbox" id="setting-radio-autotune" checked><span class="toggle-slider"></span></label></div>
      <div class="settings-row"><label>Split VFO (Full Duplex)</label><label class="toggle"><input type="checkbox" id="setting-radio-split"><span class="toggle-slider"></span></label></div>
      <div class="settings-row" style="padding-top:4px;">
        <button class="btn-sm" id="btn-radio-connect" style="width:100%;padding:8px 16px;font-size:11px;letter-spacing:1.5px;">CONNECT RADIO</button>
      </div>
      <div id="radio-status-msg" style="font-size:10px;color:var(--text-muted);text-align:center;padding:0 18px;display:none;"></div>
      <div id="radio-no-webserial" style="font-size:10px;color:var(--orange);text-align:center;padding:4px 18px;display:none;">
        WebSerial not available. Use Chrome/Edge 89+ on HTTPS or localhost, or use rigctld.
      </div>
    </div>

    <div class="modal-buttons" style="margin-top:16px;">
      <button class="btn-cancel" id="btn-refresh-tle">Refresh TLE Data</button>
      <button class="btn-primary" id="btn-settings-close">Save &amp; Close</button>
    </div>
  </div>
</div>

<script src="https://cesium.com/downloads/cesiumjs/releases/1.126/Build/Cesium/Cesium.js"></script>
<script src="https://unpkg.com/satellite.js@5.0.0/dist/satellite.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.min.js"></script>
<script>
'use strict';

const EARTH_R = 6371.0;
const C = 299792.458; // km/s speed of light
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

const SATELLITE_CATALOG = [
  { name: 'ISS (ZARYA)',      noradId: 25544, category: 'Space Stations', uplink: 145.825,  downlink: 437.800,  mode: 'FM Voice/APRS', color: '#4da6ff' },
  { name: 'ISS (NAUKA)',      noradId: 49044, category: 'Space Stations', uplink: null,      downlink: 437.800,  mode: 'Telemetry',     color: '#80caff' },
  { name: 'SO-50',            noradId: 27607, category: 'Amateur Radio',  uplink: 145.850,  downlink: 436.795,  mode: 'FM Repeater',   color: '#ff5c8a' },
  { name: 'AO-91 (FOX-1B)',   noradId: 43017, category: 'Amateur Radio',  uplink: 435.250,  downlink: 145.960,  mode: 'FM Transponder',color: '#56d364' },
  { name: 'AO-95 (FOX-1Cliff)',noradId: 43770, category: 'Amateur Radio', uplink: 435.300,  downlink: 145.920,  mode: 'FM Transponder',color: '#db61a2' },
  { name: 'XW-3 (CAS-9)',     noradId: 50466, category: 'Amateur Radio',  uplink: 435.150,  downlink: 145.870,  mode: 'Linear Transp', color: '#f0883e' },
  { name: 'AO-73 (FUNcube-1)',noradId: 39444, category: 'Amateur Radio',  uplink: 435.150,  downlink: 145.935,  mode: 'Linear/Telem',  color: '#d2a8ff' },
  { name: 'TEVEL-1',          noradId: 63217, category: 'Amateur Radio',  uplink: 145.970,  downlink: 436.400,  mode: 'FM Transponder', color: '#e3b341' },
  { name: 'NOAA 15',          noradId: 25338, category: 'Weather/APT',    uplink: null,      downlink: 137.620,  mode: 'APT 2400bps',   color: '#79c0ff' },
  { name: 'NOAA 18',          noradId: 28654, category: 'Weather/APT',    uplink: null,      downlink: 137.9125, mode: 'APT 2400bps',   color: '#7ee787' },
  { name: 'NOAA 19',          noradId: 33591, category: 'Weather/APT',    uplink: null,      downlink: 137.100,  mode: 'APT 2400bps',   color: '#ffa657' },
  { name: 'FOX-1A (AO-85)',   noradId: 40967, category: 'Amateur Radio',  uplink: 435.180,  downlink: 145.980,  mode: 'FM Transponder', color: '#ff6b6b' },
];

const CELESTRAK_GROUPS = ['stations', 'amateur', 'noaa'];

// Radio model database — { name, baud, civAddr (Icom only) }
const RADIO_MODELS = {
  kenwood: [
    { name: 'TS-2000', baud: 9600 },
    { name: 'TS-590S/SG', baud: 9600 },
    { name: 'TS-890S', baud: 115200 },
    { name: 'TS-480', baud: 9600 },
    { name: 'Elecraft K3/K3S', baud: 38400 },
    { name: 'Elecraft KX3/KX2', baud: 38400 },
    { name: 'Flex 6000 Series', baud: 9600 },
    { name: 'Other (Kenwood-compatible)', baud: 9600 },
  ],
  icom: [
    { name: 'IC-705', baud: 115200, civAddr: 0xA4 },
    { name: 'IC-7300', baud: 115200, civAddr: 0x94 },
    { name: 'IC-9700', baud: 115200, civAddr: 0xA2 },
    { name: 'IC-910H', baud: 19200, civAddr: 0x60 },
    { name: 'IC-7100', baud: 19200, civAddr: 0x88 },
    { name: 'IC-7610', baud: 115200, civAddr: 0x98 },
    { name: 'IC-9100', baud: 19200, civAddr: 0x7C },
    { name: 'IC-R8600', baud: 115200, civAddr: 0x96 },
    { name: 'Other Icom', baud: 9600, civAddr: 0x94 },
  ],
  yaesu: [
    { name: 'FT-991A', baud: 38400 },
    { name: 'FTDX10', baud: 38400 },
    { name: 'FTDX101D/MP', baud: 38400 },
    { name: 'FT-710', baud: 38400 },
    { name: 'FT-817/818', baud: 4800 },
    { name: 'FT-857D', baud: 4800 },
    { name: 'FT-897D', baud: 4800 },
    { name: 'Other Yaesu (new CAT)', baud: 38400 },
  ],
  rigctld: [],
  none: [],
};

// ============================================================
// MAIDENHEAD GRID LOCATOR
// ============================================================
function latLonToGrid(lat, lon) {
  const lo = lon + 180;
  const la = lat + 90;
  const a = String.fromCharCode(65 + Math.floor(lo / 20));
  const b = String.fromCharCode(65 + Math.floor(la / 10));
  const c = Math.floor((lo % 20) / 2);
  const d = Math.floor(la % 10);
  const e = String.fromCharCode(97 + Math.floor((lo % 2) * 12));
  const f = String.fromCharCode(97 + Math.floor((la % 1) * 24));
  return `${a}${b}${c}${d}${e}${f}`;
}

// ============================================================
// HAM RADIO LOCATION DATA
// ============================================================

// ITU Region: 1=Europe/Africa/Middle East, 2=Americas, 3=Asia/Pacific
function getITURegion(lat, lon) {
  if (lon >= -170 && lon < -20) return 2; // Americas
  if (lon >= -20 && lon < 60) return 1;   // Europe/Africa
  if (lon >= 60 || lon < -170) return 3;  // Asia/Pacific
  return 1;
}

// Approximate ITU Zone from lat/lon (simplified — 75 zones covering the globe)
// This is a reasonable approximation; exact boundaries follow country borders
function getITUZone(lat, lon) {
  // North America
  if (lat >= 50 && lon >= -170 && lon < -130) return 1;   // Alaska/NW Canada
  if (lat >= 50 && lon >= -130 && lon < -80) return 2;    // Canada
  if (lat >= 50 && lon >= -80 && lon < -50) return 3;     // NE Canada
  if (lat >= 40 && lat < 50 && lon >= -130 && lon < -100) return 6; // NW US
  if (lat >= 40 && lat < 50 && lon >= -100 && lon < -70) return 7;  // NE US
  if (lat >= 25 && lat < 40 && lon >= -130 && lon < -100) return 6; // SW US
  if (lat >= 25 && lat < 40 && lon >= -100 && lon < -70) return 8;  // SE US
  if (lat >= 10 && lat < 25 && lon >= -120 && lon < -85) return 10; // Mexico/Central Am
  if (lat >= 10 && lat < 25 && lon >= -85 && lon < -60) return 11;  // Caribbean
  // South America
  if (lat >= -10 && lat < 10 && lon >= -85 && lon < -50) return 12;  // N South America
  if (lat >= -35 && lat < -10 && lon >= -80 && lon < -50) return 14; // Central SA
  if (lat >= -35 && lat < -10 && lon >= -50 && lon < -30) return 15; // E Brazil
  if (lat < -35 && lon >= -80 && lon < -50) return 16;               // S South America
  // Europe
  if (lat >= 55 && lon >= -20 && lon < 10) return 18;  // UK/Scandinavia/Iceland
  if (lat >= 55 && lon >= 10 && lon < 30) return 18;   // N Europe
  if (lat >= 45 && lat < 55 && lon >= -10 && lon < 10) return 27;  // W Europe
  if (lat >= 45 && lat < 55 && lon >= 10 && lon < 30) return 28;   // C Europe
  if (lat >= 35 && lat < 45 && lon >= -10 && lon < 20) return 33;  // S Europe
  if (lat >= 35 && lat < 45 && lon >= 20 && lon < 45) return 39;   // E Med
  // Russia
  if (lat >= 55 && lon >= 30 && lon < 60) return 29;   // European Russia
  if (lat >= 55 && lon >= 60 && lon < 90) return 30;   // W Siberia
  if (lat >= 55 && lon >= 90 && lon < 120) return 31;  // C Siberia
  if (lat >= 55 && lon >= 120 && lon < 170) return 32;  // E Siberia
  // Africa
  if (lat >= 20 && lat < 35 && lon >= -20 && lon < 20) return 33;  // N Africa
  if (lat >= 20 && lat < 35 && lon >= 20 && lon < 45) return 34;   // NE Africa
  if (lat >= 0 && lat < 20 && lon >= -20 && lon < 20) return 35;   // W Africa
  if (lat >= 0 && lat < 20 && lon >= 20 && lon < 50) return 37;    // E Africa
  if (lat >= -35 && lat < 0 && lon >= 10 && lon < 50) return 53;   // S Africa
  // Middle East / Central Asia
  if (lat >= 25 && lat < 45 && lon >= 45 && lon < 70) return 40;  // Middle East
  if (lat >= 35 && lat < 55 && lon >= 45 && lon < 80) return 30;  // Central Asia
  // South Asia
  if (lat >= 5 && lat < 35 && lon >= 70 && lon < 90) return 41;   // India
  if (lat >= 15 && lat < 35 && lon >= 90 && lon < 105) return 49;  // SE Asia
  // East Asia
  if (lat >= 35 && lat < 55 && lon >= 100 && lon < 130) return 44; // China/Mongolia
  if (lat >= 30 && lat < 45 && lon >= 130 && lon < 145) return 45; // Japan
  if (lat >= 15 && lat < 35 && lon >= 100 && lon < 120) return 49; // SE Asia
  // Southeast Asia / Indonesia
  if (lat >= -10 && lat < 15 && lon >= 95 && lon < 130) return 54; // Indonesia/Philippines
  // Oceania
  if (lat >= -50 && lat < -10 && lon >= 110 && lon < 155) return 55; // Australia
  if (lat >= -50 && lat < -35 && lon >= 165 && lon < 180) return 60; // New Zealand
  if (lat >= 0 && lat < 30 && lon >= 140 && lon <= 180) return 56;   // Pacific Islands
  if (lat >= 0 && lat < 30 && lon >= -180 && lon < -120) return 61;  // Central Pacific
  // Antarctica
  if (lat < -60) return 67 + Math.floor(((lon + 180) % 360) / 90);
  // Fallback — use longitude bands
  const band = Math.floor(((lon + 180) % 360) / 20);
  return Math.min(75, Math.max(1, band + 1));
}

// Approximate CQ Zone from lat/lon (40 zones for CQ contests)
function getCQZone(lat, lon) {
  // North America
  if (lat >= 50 && lon >= -170 && lon < -130) return 1;    // NW NA / Alaska
  if (lat >= 50 && lon >= -130 && lon < -70) return 2;     // Canada
  if (lat >= 50 && lon >= -70 && lon < -50) return 2;      // Atlantic Canada
  if (lat >= 30 && lat < 50 && lon >= -130 && lon < -100) return 3;  // W US
  if (lat >= 30 && lat < 50 && lon >= -100 && lon < -70) return 4;   // Central/E US
  if (lat >= 25 && lat < 50 && lon >= -70 && lon < -50) return 5;    // NE US/Maritimes
  if (lat >= 10 && lat < 30 && lon >= -130 && lon < -85) return 6;   // Mexico
  if (lat >= 10 && lat < 25 && lon >= -85 && lon < -60) return 8;    // Caribbean/Central Am
  // South America
  if (lat >= -10 && lat < 10 && lon >= -85 && lon < -50) return 9;   // N SA
  if (lat >= -35 && lat < -10 && lon >= -80 && lon < -50) return 11;  // C SA / Brazil
  if (lat < -35 && lon >= -80 && lon < -50) return 13;                // S SA
  // Europe
  if (lat >= 55 && lon >= -30 && lon < 40) return 14;  // N Europe
  if (lat >= 45 && lat < 55 && lon >= -10 && lon < 20) return 14;   // W Europe
  if (lat >= 45 && lat < 55 && lon >= 20 && lon < 50) return 15;    // E Europe
  if (lat >= 35 && lat < 45 && lon >= -10 && lon < 20) return 14;   // S Europe
  if (lat >= 35 && lat < 45 && lon >= 20 && lon < 50) return 20;    // E Med
  // Russia / N Asia
  if (lat >= 50 && lon >= 40 && lon < 80) return 16;     // European Russia/Urals
  if (lat >= 50 && lon >= 80 && lon < 110) return 17;    // W Siberia
  if (lat >= 50 && lon >= 110 && lon < 140) return 18;   // C Siberia
  if (lat >= 50 && lon >= 140 && lon < 170) return 19;   // E Siberia
  // Africa
  if (lat >= 20 && lat < 38 && lon >= -20 && lon < 30) return 33;  // N Africa
  if (lat >= 0 && lat < 20 && lon >= -20 && lon < 20) return 35;   // W Africa
  if (lat >= 0 && lat < 20 && lon >= 20 && lon < 55) return 34;    // E Africa
  if (lat >= -40 && lat < 0 && lon >= 10 && lon < 55) return 36;   // S Africa
  // Middle East
  if (lat >= 20 && lat < 45 && lon >= 30 && lon < 65) return 21;   // Middle East
  // South/SE Asia
  if (lat >= 10 && lat < 40 && lon >= 65 && lon < 90) return 22;   // India/Pakistan
  if (lat >= 10 && lat < 35 && lon >= 90 && lon < 115) return 26;  // SE Asia
  if (lat >= 35 && lat < 55 && lon >= 90 && lon < 130) return 23;  // China
  if (lat >= 25 && lat < 45 && lon >= 130 && lon < 145) return 25;  // Japan/Korea
  if (lat >= -10 && lat < 10 && lon >= 95 && lon < 140) return 28;  // Indonesia
  // Oceania
  if (lat >= -50 && lat < -10 && lon >= 110 && lon < 160) return 29; // Australia
  if (lat >= -50 && lat < -30 && lon >= 160 && lon <= 180) return 32; // New Zealand
  if (lat >= -30 && lat < 30 && lon >= 150 && lon <= 180) return 31;  // Pacific
  if (lat >= -30 && lat < 30 && lon >= -180 && lon < -100) return 31; // Pacific
  // Antarctica
  if (lat < -60) return 39;
  // Fallback
  return 14;
}

// Country to DXCC entity and callsign prefix mapping
const COUNTRY_HAM_DATA = {
  'US': { dxcc: 'K (291)', prefix: 'K/W/N/AA-AL', name: 'United States' },
  'CA': { dxcc: 'VE (1)', prefix: 'VE/VA/VY', name: 'Canada' },
  'MX': { dxcc: 'XE (50)', prefix: 'XE/XA', name: 'Mexico' },
  'GB': { dxcc: 'G (223)', prefix: 'G/M/2E', name: 'England' },
  'DE': { dxcc: 'DL (230)', prefix: 'DL/DA-DR', name: 'Germany' },
  'FR': { dxcc: 'F (227)', prefix: 'F', name: 'France' },
  'ES': { dxcc: 'EA (281)', prefix: 'EA/EB/EC', name: 'Spain' },
  'IT': { dxcc: 'I (248)', prefix: 'I/IK/IZ', name: 'Italy' },
  'PT': { dxcc: 'CT (272)', prefix: 'CT', name: 'Portugal' },
  'NL': { dxcc: 'PA (263)', prefix: 'PA/PD/PE', name: 'Netherlands' },
  'BE': { dxcc: 'ON (209)', prefix: 'ON', name: 'Belgium' },
  'CH': { dxcc: 'HB (287)', prefix: 'HB', name: 'Switzerland' },
  'AT': { dxcc: 'OE (206)', prefix: 'OE', name: 'Austria' },
  'PL': { dxcc: 'SP (269)', prefix: 'SP/SQ/SO', name: 'Poland' },
  'CZ': { dxcc: 'OK (503)', prefix: 'OK', name: 'Czech Republic' },
  'SE': { dxcc: 'SM (284)', prefix: 'SM/SA-SK', name: 'Sweden' },
  'NO': { dxcc: 'LA (266)', prefix: 'LA/LB', name: 'Norway' },
  'FI': { dxcc: 'OH (224)', prefix: 'OH', name: 'Finland' },
  'DK': { dxcc: 'OZ (222)', prefix: 'OZ', name: 'Denmark' },
  'IE': { dxcc: 'EI (245)', prefix: 'EI', name: 'Ireland' },
  'RU': { dxcc: 'UA (15)', prefix: 'UA/RA/R', name: 'Russia' },
  'UA': { dxcc: 'UR (288)', prefix: 'UR/UT/UX', name: 'Ukraine' },
  'JP': { dxcc: 'JA (339)', prefix: 'JA/JH/JR', name: 'Japan' },
  'KR': { dxcc: 'HL (137)', prefix: 'HL/DS', name: 'South Korea' },
  'CN': { dxcc: 'BY (318)', prefix: 'BY/BV', name: 'China' },
  'IN': { dxcc: 'VU (324)', prefix: 'VU/AT', name: 'India' },
  'AU': { dxcc: 'VK (150)', prefix: 'VK', name: 'Australia' },
  'NZ': { dxcc: 'ZL (170)', prefix: 'ZL', name: 'New Zealand' },
  'BR': { dxcc: 'PY (108)', prefix: 'PY/PP/PR', name: 'Brazil' },
  'AR': { dxcc: 'LU (100)', prefix: 'LU/LW', name: 'Argentina' },
  'CL': { dxcc: 'CE (112)', prefix: 'CE', name: 'Chile' },
  'CO': { dxcc: 'HK (116)', prefix: 'HK', name: 'Colombia' },
  'ZA': { dxcc: 'ZS (462)', prefix: 'ZS/ZR', name: 'South Africa' },
  'EG': { dxcc: 'SU (478)', prefix: 'SU', name: 'Egypt' },
  'NG': { dxcc: '5N (450)', prefix: '5N', name: 'Nigeria' },
  'KE': { dxcc: '5Z (430)', prefix: '5Z', name: 'Kenya' },
  'IL': { dxcc: '4X (336)', prefix: '4X/4Z', name: 'Israel' },
  'SA': { dxcc: 'HZ (378)', prefix: 'HZ', name: 'Saudi Arabia' },
  'TH': { dxcc: 'HS (387)', prefix: 'HS', name: 'Thailand' },
  'ID': { dxcc: 'YB (327)', prefix: 'YB/YC/YD', name: 'Indonesia' },
  'PH': { dxcc: 'DU (375)', prefix: 'DU/DV/DX', name: 'Philippines' },
  'MY': { dxcc: '9M (299)', prefix: '9M/9W', name: 'Malaysia' },
  'SG': { dxcc: '9V (381)', prefix: '9V', name: 'Singapore' },
  'GR': { dxcc: 'SV (236)', prefix: 'SV', name: 'Greece' },
  'TR': { dxcc: 'TA (390)', prefix: 'TA/TB', name: 'Turkey' },
  'RO': { dxcc: 'YO (275)', prefix: 'YO/YP/YR', name: 'Romania' },
  'HU': { dxcc: 'HA (239)', prefix: 'HA/HG', name: 'Hungary' },
  'HR': { dxcc: '9A (497)', prefix: '9A', name: 'Croatia' },
};

function getCountryHamData(countryCode) {
  if (!countryCode) return null;
  return COUNTRY_HAM_DATA[countryCode.toUpperCase()] || null;
}

// Callsign prefix → country code detection
// Sorted longest-first so "VK" matches before "V"
const CALLSIGN_PREFIXES = [
  // Multi-char prefixes first
  ['AA','US'],['AB','US'],['AC','US'],['AD','US'],['AE','US'],['AF','US'],['AG','US'],['AH','US'],['AI','US'],['AJ','US'],['AK','US'],['AL','US'],
  ['BY','CN'],['BV','CN'],
  ['CE','CL'],['CM','CU'],['CO','CU'],['CP','BO'],['CT','PT'],['CU','PT'],['CX','UY'],
  ['DA','DE'],['DB','DE'],['DC','DE'],['DD','DE'],['DE','DE'],['DF','DE'],['DG','DE'],['DH','DE'],['DI','DE'],['DJ','DE'],['DK','DE'],['DL','DE'],['DM','DE'],['DN','DE'],['DO','DE'],['DP','DE'],['DQ','DE'],['DR','DE'],['DS','KR'],['DU','PH'],['DV','PH'],['DX','PH'],
  ['EA','ES'],['EB','ES'],['EC','ES'],['ED','ES'],['EE','ES'],['EF','ES'],['EH','ES'],['EI','IE'],['EK','AM'],['EL','LR'],['EP','IR'],['ER','MD'],['ES','EE'],['ET','ET'],['EU','BY'],['EW','BY'],['EX','KG'],['EY','TJ'],['EZ','TM'],
  ['F','FR'],
  ['G','GB'],['GM','GB'],['GW','GB'],['GI','GB'],['GD','GB'],['GU','GB'],['GJ','GB'],
  ['HA','HU'],['HB','CH'],['HC','EC'],['HH','HT'],['HI','DO'],['HK','CO'],['HL','KR'],['HP','PA'],['HR','HN'],['HS','TH'],['HZ','SA'],
  ['I','IT'],['IK','IT'],['IZ','IT'],
  ['JA','JP'],['JE','JP'],['JF','JP'],['JG','JP'],['JH','JP'],['JI','JP'],['JJ','JP'],['JK','JP'],['JL','JP'],['JM','JP'],['JN','JP'],['JO','JP'],['JP','JP'],['JQ','JP'],['JR','JP'],['JS','JP'],['JT','MN'],
  ['K','US'],
  ['LA','NO'],['LB','NO'],['LU','AR'],['LW','AR'],['LX','LU'],['LY','LT'],['LZ','BG'],
  ['N','US'],
  ['OA','PE'],['OD','LB'],['OE','AT'],['OF','FI'],['OG','FI'],['OH','FI'],['OI','FI'],['OK','CZ'],['OM','SK'],['ON','BE'],['OO','BE'],['OP','BE'],['OQ','BE'],['OR','BE'],['OS','BE'],['OT','BE'],['OU','DK'],['OV','DK'],['OW','DK'],['OX','DK'],['OY','DK'],['OZ','DK'],
  ['PA','NL'],['PB','NL'],['PC','NL'],['PD','NL'],['PE','NL'],['PF','NL'],['PG','NL'],['PH','NL'],['PI','NL'],['PJ','NL'],['PP','BR'],['PQ','BR'],['PR','BR'],['PS','BR'],['PT','BR'],['PU','BR'],['PV','BR'],['PW','BR'],['PX','BR'],['PY','BR'],
  ['RA','RU'],['RB','RU'],['RC','RU'],['RD','RU'],['RE','RU'],['RF','RU'],['RG','RU'],['RH','RU'],['RI','RU'],['RJ','RU'],['RK','RU'],['RL','RU'],['RM','RU'],['RN','RU'],['RO','RU'],['RP','RU'],['RQ','RU'],['RR','RU'],['RS','RU'],['RT','RU'],['RU','RU'],['RV','RU'],['RW','RU'],['RX','RU'],['RY','RU'],['RZ','RU'],
  ['SA','SE'],['SB','SE'],['SC','SE'],['SD','SE'],['SE','SE'],['SF','SE'],['SG','SE'],['SH','SE'],['SI','SE'],['SJ','SE'],['SK','SE'],['SL','SE'],['SM','SE'],['SN','PL'],['SO','PL'],['SP','PL'],['SQ','PL'],['SR','PL'],['SU','EG'],['SV','GR'],['SW','GR'],['SX','GR'],['SY','GR'],['SZ','GR'],
  ['TA','TR'],['TB','TR'],['TC','TR'],['TF','IS'],['TG','GT'],['TI','CR'],['TJ','CM'],['TK','FR'],['TL','CF'],['TN','CG'],['TR','GA'],['TT','TD'],['TU','CI'],['TY','BJ'],['TZ','ML'],
  ['UA','RU'],['UB','RU'],['UC','RU'],['UD','RU'],['UE','RU'],['UF','RU'],['UG','RU'],['UH','RU'],['UI','RU'],['UN','KZ'],['UO','KZ'],['UP','KZ'],['UQ','KZ'],['UR','UA'],['US','UA'],['UT','UA'],['UU','UA'],['UV','UA'],['UW','UA'],['UX','UA'],['UY','UA'],['UZ','UA'],
  ['VA','CA'],['VB','CA'],['VC','CA'],['VD','CA'],['VE','CA'],['VF','CA'],['VG','CA'],['VH','AU'],['VI','AU'],['VJ','AU'],['VK','AU'],['VL','AU'],['VM','AU'],['VN','AU'],['VO','CA'],['VP','GB'],['VQ','GB'],['VR','CN'],['VS','GB'],['VU','IN'],['VV','IN'],['VW','IN'],['VX','CA'],['VY','CA'],
  ['W','US'],
  ['XA','MX'],['XB','MX'],['XC','MX'],['XD','MX'],['XE','MX'],['XF','MX'],
  ['YA','AF'],['YB','ID'],['YC','ID'],['YD','ID'],['YE','ID'],['YI','IQ'],['YJ','VU'],['YK','SY'],['YL','LV'],['YM','TR'],['YN','NI'],['YO','RO'],['YP','RO'],['YQ','RO'],['YR','RO'],['YS','SV'],['YT','RS'],['YU','RS'],['YV','VE'],['YW','VE'],['YX','VE'],['YY','VE'],
  ['ZA','AL'],['ZB','GB'],['ZC','GB'],['ZD','GB'],['ZF','GB'],['ZL','NZ'],['ZM','NZ'],['ZP','PY'],['ZR','ZA'],['ZS','ZA'],['ZT','ZA'],['ZU','ZA'],
  ['2E','GB'],['2D','GB'],['2I','GB'],['2M','GB'],['2W','GB'],
  ['3A','MC'],['3B','MU'],['3C','GQ'],['3D','SZ'],['3V','TN'],['3W','VN'],['3X','GN'],
  ['4J','AZ'],['4K','AZ'],['4L','GE'],['4O','ME'],['4S','LK'],['4U','CH'],['4X','IL'],['4Z','IL'],
  ['5A','LY'],['5B','CY'],['5H','TZ'],['5N','NG'],['5R','MG'],['5T','MR'],['5U','NE'],['5V','TG'],['5W','WS'],['5X','UG'],['5Y','KE'],['5Z','KE'],
  ['6W','SN'],['6Y','JM'],
  ['7J','JP'],['7K','JP'],['7L','JP'],['7M','JP'],['7N','JP'],['7P','LS'],['7Q','MW'],['7X','DZ'],
  ['8P','BB'],['8Q','MV'],['8R','GY'],
  ['9A','HR'],['9G','GH'],['9H','MT'],['9J','ZM'],['9K','KW'],['9L','SL'],['9M','MY'],['9N','NP'],['9V','SG'],['9W','MY'],['9X','RW'],['9Y','TT'],
];

function detectCallsignCountry(callsign) {
  if (!callsign || callsign.length < 2) return null;
  const cs = callsign.toUpperCase().replace(/[^A-Z0-9]/g, '');
  // Try 2-char prefix first, then 1-char
  for (const [prefix, cc] of CALLSIGN_PREFIXES) {
    if (cs.startsWith(prefix)) {
      const hamData = COUNTRY_HAM_DATA[cc];
      return { countryCode: cc, name: hamData ? hamData.name : cc, prefix: prefix, dxcc: hamData ? hamData.dxcc : cc };
    }
  }
  return null;
}

// Estimate UTC offset from longitude (rough, doesn't account for timezone boundaries)
function getUTCOffsetFromLon(lon) {
  const offset = Math.round(lon / 15);
  return offset >= 0 ? `UTC+${offset}` : `UTC${offset}`;
}

// Get sunrise/sunset for location using SunCalc
function getSunTimes(lat, lon) {
  const times = SunCalc.getTimes(new Date(), lat, lon);
  const fmt = d => {
    if (!d || isNaN(d.getTime())) return '--:--';
    return d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'UTC' });
  };
  return `${fmt(times.sunrise)} / ${fmt(times.sunset)} UTC`;
}

// Geocode a place name using OpenStreetMap Nominatim (free, no API key)
let geocodeTimeout = null;
async function geocodeSearch(query) {
  if (!query || query.length < 2) return [];
  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&addressdetails=1`;
  try {
    const resp = await fetch(url, { headers: { 'Accept-Language': 'en' } });
    if (!resp.ok) return [];
    return await resp.json();
  } catch (e) { return []; }
}

// Compute all derived ham radio data from lat/lon/country
function computeDerivedHamData(lat, lon, countryCode) {
  const grid = latLonToGrid(lat, lon).toUpperCase();
  const ituZone = getITUZone(lat, lon);
  const cqZone = getCQZone(lat, lon);
  const ituRegion = getITURegion(lat, lon);
  const utcOffset = getUTCOffsetFromLon(lon);
  const sunTimes = getSunTimes(lat, lon);
  const hamData = getCountryHamData(countryCode);

  return {
    grid,
    ituZone,
    cqZone,
    ituRegion,
    utcOffset,
    sunTimes,
    dxcc: hamData ? hamData.dxcc : '--',
    prefix: hamData ? hamData.prefix : '--',
    country: hamData ? hamData.name : (countryCode || '--'),
  };
}

// Update the derived data display in the location modal
function updateDerivedDisplay(lat, lon, countryCode) {
  if (isNaN(lat) || isNaN(lon)) return;
  const d = computeDerivedHamData(lat, lon, countryCode);
  document.getElementById('derived-grid').textContent = d.grid;
  document.getElementById('derived-itu').textContent = d.ituZone;
  document.getElementById('derived-cq').textContent = d.cqZone;
  document.getElementById('derived-region').textContent = `Region ${d.ituRegion}`;
  document.getElementById('derived-dxcc').textContent = d.dxcc;
  document.getElementById('derived-prefix').textContent = d.prefix;
  document.getElementById('derived-utc').textContent = d.utcOffset;
  document.getElementById('derived-sun').textContent = d.sunTimes;
}

// ============================================================
// DOPPLER SHIFT
// ============================================================
function computeDoppler(freqMHz, rangeRateKmS) {
  const shiftMHz = -freqMHz * (rangeRateKmS / C);
  return shiftMHz;
}

function getRangeRate(satrec, observerGd, date) {
  const dt = 0.5;
  const d1 = new Date(date.getTime() - dt * 500);
  const d2 = new Date(date.getTime() + dt * 500);
  const la1 = getLookAngles(satrec, observerGd, d1);
  const la2 = getLookAngles(satrec, observerGd, d2);
  if (!la1 || !la2) return 0;
  return (la2.range - la1.range) / dt;
}

// Pre-compute Doppler curve across a pass for visualization
function computeDopplerCurve(satrec, oGd, pass, freqMHz, numPoints) {
  if (!pass || !freqMHz) return [];
  const n = numPoints || 40;
  const padMs = 60000; // 1 min padding before/after
  const tStart = pass.start.getTime() - padMs;
  const tEnd = pass.end.getTime() + padMs;
  const dt = (tEnd - tStart) / (n - 1);
  const points = [];
  for (let i = 0; i < n; i++) {
    const t = tStart + i * dt;
    const d = new Date(t);
    const rr = getRangeRate(satrec, oGd, d);
    const la = getLookAngles(satrec, oGd, d);
    const shift = computeDoppler(freqMHz, rr);
    points.push({
      time: t,
      shiftHz: shift * 1000,
      elevation: la ? la.elevation : 0,
      inPass: t >= pass.start.getTime() && t <= pass.end.getTime()
    });
  }
  return points;
}

// ============================================================
// SIGNAL STRENGTH ESTIMATION
// ============================================================
function estimateSignalLevel(elevation, range, altKm) {
  if (elevation < 0) return 0;
  const maxRange = Math.sqrt((EARTH_R + altKm) ** 2 - EARTH_R ** 2);
  const rangeFactor = 1 - (range / (maxRange * 1.2));
  const elevFactor = Math.sin(elevation * DEG2RAD);
  const combined = (rangeFactor * 0.4 + elevFactor * 0.6);
  return Math.max(0, Math.min(9, Math.round(combined * 9)));
}

// ============================================================
// RADIO CAT PROTOCOL DRIVERS
// ============================================================

// Kenwood / Elecraft ASCII protocol — also used by Flex, many SDRs
const KenwoodProtocol = {
  name: 'kenwood',
  setFreqA(freqHz) { return new TextEncoder().encode('FA' + String(Math.round(freqHz)).padStart(11, '0') + ';'); },
  setFreqB(freqHz) { return new TextEncoder().encode('FB' + String(Math.round(freqHz)).padStart(11, '0') + ';'); },
  getFreqA() { return new TextEncoder().encode('FA;'); },
  setMode(mode) {
    const m = { 'FM': 4, 'USB': 2, 'LSB': 1, 'CW': 3, 'CW-R': 7, 'AM': 5 }[mode] ?? 4;
    return new TextEncoder().encode('MD' + m + ';');
  },
  parseResponse(text) {
    if (text.startsWith('FA') && text.endsWith(';')) return { type: 'freqA', value: parseInt(text.slice(2, -1)) };
    if (text.startsWith('FB') && text.endsWith(';')) return { type: 'freqB', value: parseInt(text.slice(2, -1)) };
    return null;
  },
  delimiter: 0x3B,
};

// Icom CI-V binary protocol
const IcomProtocol = {
  name: 'icom',
  addresses: {
    'IC-705': 0xA4, 'IC-7300': 0x94, 'IC-9700': 0xA2,
    'IC-910H': 0x60, 'IC-7100': 0x88, 'IC-7610': 0x98,
    'IC-R8600': 0x96, 'IC-9100': 0x7C,
  },
  _frame(civAddr, cmd, subCmd, data) {
    const parts = [0xFE, 0xFE, civAddr, 0xE0, cmd];
    if (subCmd !== null && subCmd !== undefined) parts.push(subCmd);
    if (data) parts.push(...data);
    parts.push(0xFD);
    return new Uint8Array(parts);
  },
  _freqToBCD(freqHz) {
    const s = String(Math.round(freqHz)).padStart(10, '0');
    const bcd = [];
    for (let i = 8; i >= 0; i -= 2) bcd.push((parseInt(s[i]) << 4) | parseInt(s[i + 1]));
    return bcd;
  },
  setFreq(civAddr, freqHz) { return this._frame(civAddr, 0x05, null, this._freqToBCD(freqHz)); },
  selectVfoA(civAddr) { return this._frame(civAddr, 0x07, 0x00, null); },
  selectVfoB(civAddr) { return this._frame(civAddr, 0x07, 0x01, null); },
  setMode(civAddr, mode) {
    const m = { 'LSB': 0x00, 'USB': 0x01, 'AM': 0x02, 'CW': 0x03, 'FM': 0x05, 'CW-R': 0x07 }[mode] ?? 0x05;
    return this._frame(civAddr, 0x06, m, [0x01]);
  },
  getFreq(civAddr) { return this._frame(civAddr, 0x03, null, null); },
};

// Yaesu old-style 5-byte protocol — FT-817/818/857/897
const YaesuOldProtocol = {
  name: 'yaesu_old',
  setFreq(freqHz) {
    const mhz10 = Math.round(freqHz / 10);
    const s = String(mhz10).padStart(8, '0');
    const bytes = new Uint8Array(5);
    for (let i = 0; i < 4; i++) bytes[i] = (parseInt(s[i * 2]) << 4) | parseInt(s[i * 2 + 1]);
    bytes[4] = 0x01;
    return bytes;
  },
  setMode(mode) {
    const m = { 'LSB': 0x00, 'USB': 0x01, 'CW': 0x02, 'CW-R': 0x03, 'AM': 0x04, 'FM': 0x08, 'DIG': 0x0A, 'PKT': 0x0C }[mode] ?? 0x08;
    return new Uint8Array([m, 0x00, 0x00, 0x00, 0x07]);
  },
  getFreqMode() { return new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x03]); },
};

// Yaesu new-style ASCII protocol — FT-991A, FTDX10, FTDX101D, FT-710
const YaesuNewProtocol = {
  name: 'yaesu_new',
  setFreqA(freqHz) { return new TextEncoder().encode('FA' + String(Math.round(freqHz)).padStart(9, '0') + ';'); },
  setFreqB(freqHz) { return new TextEncoder().encode('FB' + String(Math.round(freqHz)).padStart(9, '0') + ';'); },
  getFreqA() { return new TextEncoder().encode('FA;'); },
  setMode(mode) {
    const m = { 'LSB': 1, 'USB': 2, 'CW': 3, 'FM': 4, 'AM': 5, 'CW-R': 7, 'DATA-USB': 9, 'FM-N': 11 }[mode] ?? 4;
    return new TextEncoder().encode('MD0' + m + ';');
  },
  delimiter: 0x3B,
};

// rigctld text protocol (over WebSocket)
const RigctldProtocol = {
  name: 'rigctld',
  setFreq(freqHz) { return 'F ' + Math.round(freqHz) + '\n'; },
  getFreq() { return 'f\n'; },
  setMode(mode, bandwidth) { return 'M ' + mode + ' ' + (bandwidth || 0) + '\n'; },
  setVfo(vfo) { return 'V ' + vfo + '\n'; },
  parseResponse(text) {
    const lines = text.trim().split('\n');
    const num = parseInt(lines[0]);
    if (!isNaN(num) && num > 1000000) return { type: 'freq', value: num };
    if (lines[0].startsWith('RPRT')) return { type: 'rprt', value: parseInt(lines[0].split(' ')[1]) };
    return { type: 'raw', value: text };
  },
};

// ============================================================
// RADIO TRANSPORT: WebSerial
// ============================================================
const RadioSerial = {
  async connect() {
    if (!('serial' in navigator)) throw new Error('WebSerial not supported. Use Chrome/Edge 89+ on HTTPS or localhost.');
    const port = await navigator.serial.requestPort();
    await port.open({ baudRate: state.radio.config.baudRate });
    state.radio.port = port;
    state.radio.writer = port.writable.getWriter();
    state.radio.transport = 'serial';
    state.radio.rxBuffer = new Uint8Array(0);
    this._readLoop(port);
    state.radio.connected = true;
    const brand = state.radio.config.brand;
    const oldModels = ['FT-817', 'FT-818', 'FT-857', 'FT-897'];
    state.radio.protocol = brand === 'icom' ? 'icom'
      : brand === 'yaesu' ? (oldModels.some(m => state.radio.config.model.includes(m)) ? 'yaesu_old' : 'yaesu_new')
      : 'kenwood';
    updateRadioStatusUI();
  },
  async _readLoop(port) {
    const reader = port.readable.getReader();
    state.radio.reader = reader;
    try {
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        if (value) {
          const prev = state.radio.rxBuffer;
          const buf = new Uint8Array(prev.length + value.length);
          buf.set(prev); buf.set(value, prev.length);
          state.radio.rxBuffer = buf;
        }
      }
    } catch (e) { if (state.radio.connected) { console.warn('Serial read error:', e); this.disconnect(); } }
  },
  async send(data) {
    if (!state.radio.writer) return;
    try { await state.radio.writer.write(data instanceof Uint8Array ? data : new TextEncoder().encode(data)); }
    catch (e) { console.error('Serial write error:', e); this.disconnect(); }
  },
  async disconnect() {
    state.radio.connected = false;
    try { if (state.radio.reader) { await state.radio.reader.cancel(); state.radio.reader = null; } } catch(e) {}
    try { if (state.radio.writer) { state.radio.writer.releaseLock(); state.radio.writer = null; } } catch(e) {}
    try { if (state.radio.port) { await state.radio.port.close(); state.radio.port = null; } } catch(e) {}
    state.radio.transport = null;
    state.radio.protocol = null;
    updateRadioStatusUI();
  },
};

// ============================================================
// RADIO TRANSPORT: rigctld via WebSocket
// ============================================================
const RadioRigctld = {
  async connect() {
    const { wsPort, rigctldHost } = state.radio.config;
    const url = 'ws://' + rigctldHost + ':' + wsPort;
    return new Promise((resolve, reject) => {
      const ws = new WebSocket(url);
      const timeout = setTimeout(() => { ws.close(); reject(new Error('rigctld connection timed out')); }, 5000);
      ws.onopen = () => {
        clearTimeout(timeout);
        state.radio.ws = ws;
        state.radio.connected = true;
        state.radio.transport = 'rigctld';
        state.radio.protocol = 'rigctld';
        updateRadioStatusUI();
        ws.send(RigctldProtocol.getFreq());
        resolve();
      };
      ws.onerror = () => { clearTimeout(timeout); reject(new Error('Cannot connect to rigctld WebSocket bridge at ' + url)); };
      ws.onclose = () => {
        if (state.radio.connected) {
          state.radio.connected = false;
          state.radio.transport = null;
          state.radio.protocol = null;
          updateRadioStatusUI();
        }
      };
    });
  },
  async send(data) {
    if (state.radio.ws && state.radio.ws.readyState === WebSocket.OPEN) state.radio.ws.send(data);
  },
  async disconnect() {
    state.radio.connected = false;
    if (state.radio.ws) { state.radio.ws.close(); state.radio.ws = null; }
    state.radio.transport = null;
    state.radio.protocol = null;
    updateRadioStatusUI();
  },
};

// ============================================================
// RADIO CONTROLLER
// ============================================================
const RadioController = {
  async connect() {
    try {
      if (state.radio.config.brand === 'rigctld') await RadioRigctld.connect();
      else await RadioSerial.connect();
      this.saveConfig();
    } catch (e) { throw e; }
  },
  async disconnect() {
    if (state.radio.transport === 'rigctld') await RadioRigctld.disconnect();
    else await RadioSerial.disconnect();
  },
  async _send(data) {
    if (state.radio.transport === 'rigctld') await RadioRigctld.send(data);
    else await RadioSerial.send(data);
  },
  _delay(ms) { return new Promise(r => setTimeout(r, ms)); },

  async setDownlink(freqHz) {
    const p = state.radio.protocol;
    if (p === 'kenwood') await this._send(KenwoodProtocol.setFreqA(freqHz));
    else if (p === 'icom') {
      const addr = state.radio.config.civAddress;
      if (state.radio.config.splitVfo) { await this._send(IcomProtocol.selectVfoA(addr)); await this._delay(30); }
      await this._send(IcomProtocol.setFreq(addr, freqHz));
    } else if (p === 'yaesu_old') await this._send(YaesuOldProtocol.setFreq(freqHz));
    else if (p === 'yaesu_new') await this._send(YaesuNewProtocol.setFreqA(freqHz));
    else if (p === 'rigctld') {
      if (state.radio.config.splitVfo) { await this._send(RigctldProtocol.setVfo('VFOA')); await this._delay(20); }
      await this._send(RigctldProtocol.setFreq(freqHz));
    }
  },

  async setUplink(freqHz) {
    if (!state.radio.config.splitVfo) return;
    const p = state.radio.protocol;
    if (p === 'kenwood') await this._send(KenwoodProtocol.setFreqB(freqHz));
    else if (p === 'icom') {
      const addr = state.radio.config.civAddress;
      await this._send(IcomProtocol.selectVfoB(addr)); await this._delay(30);
      await this._send(IcomProtocol.setFreq(addr, freqHz)); await this._delay(30);
      await this._send(IcomProtocol.selectVfoA(addr));
    } else if (p === 'yaesu_new') await this._send(YaesuNewProtocol.setFreqB(freqHz));
    else if (p === 'rigctld') {
      await this._send(RigctldProtocol.setVfo('VFOB')); await this._delay(20);
      await this._send(RigctldProtocol.setFreq(freqHz)); await this._delay(20);
      await this._send(RigctldProtocol.setVfo('VFOA'));
    }
  },

  async setMode(modeStr) {
    const p = state.radio.protocol;
    if (p === 'kenwood') await this._send(KenwoodProtocol.setMode(modeStr));
    else if (p === 'icom') await this._send(IcomProtocol.setMode(state.radio.config.civAddress, modeStr));
    else if (p === 'yaesu_old') await this._send(YaesuOldProtocol.setMode(modeStr));
    else if (p === 'yaesu_new') await this._send(YaesuNewProtocol.setMode(modeStr));
    else if (p === 'rigctld') await this._send(RigctldProtocol.setMode(modeStr, 0));
  },

  // Main loop hook — throttled Doppler frequency updates
  async updateDoppler() {
    if (!state.radio.connected || !state.radio.config.dopplerCorrection) return;
    if (state.activeSatId == null) return;
    const now = Date.now();
    if (now - state.radio.lastTxTime < state.radio.txInterval) return;
    const sat = state.satellites[state.activeSatId];
    if (!sat || !sat.catalogEntry) return;
    const cat = sat.catalogEntry;
    const rr = sat.rangeRate || 0;
    if (cat.downlink) {
      const dShift = computeDoppler(cat.downlink, rr);
      const correctedDown = Math.round((cat.downlink + dShift) * 1e6 / 10) * 10;
      if (correctedDown !== state.radio.lastSentDownlink) {
        state.radio.lastSentDownlink = correctedDown;
        state.radio.lastTxTime = now;
        await this.setDownlink(correctedDown);
      }
    }
    if (cat.uplink && state.radio.config.splitVfo) {
      const uShift = computeDoppler(cat.uplink, rr);
      const correctedUp = Math.round((cat.uplink - uShift) * 1e6 / 10) * 10;
      if (correctedUp !== state.radio.lastSentUplink) {
        state.radio.lastSentUplink = correctedUp;
        await this._delay(50);
        await this.setUplink(correctedUp);
      }
    }
  },

  // Called when user selects a different satellite
  async onSatelliteChange(nid) {
    if (!state.radio.connected || !state.radio.config.autoTune) return;
    const sat = state.satellites[nid];
    if (!sat || !sat.catalogEntry) return;
    state.radio.lastSentDownlink = 0;
    state.radio.lastSentUplink = 0;
    const modeStr = this._satModeToRadioMode(sat.catalogEntry.mode);
    if (modeStr) await this.setMode(modeStr);
    await this.updateDoppler();
  },

  _satModeToRadioMode(satMode) {
    if (!satMode) return 'FM';
    const m = satMode.toUpperCase();
    if (m.includes('FM')) return 'FM';
    if (m.includes('USB') || m.includes('LINEAR') || m.includes('TRANSP')) return 'USB';
    if (m.includes('LSB')) return 'LSB';
    if (m.includes('CW')) return 'CW';
    return 'FM';
  },

  saveConfig() {
    try { localStorage.setItem('sat_tracker_radio', JSON.stringify(state.radio.config)); } catch (e) {}
  },
  loadConfig() {
    try { const s = JSON.parse(localStorage.getItem('sat_tracker_radio')); if (s) Object.assign(state.radio.config, s); } catch (e) {}
  },
};

// Radio status UI helpers
function updateRadioStatusUI() {
  const el = document.getElementById('radio-indicator');
  if (!el) return;
  if (state.radio.connected) {
    el.style.display = 'flex';
    el.classList.remove('disconnected');
    el.querySelector('.radio-ind-label').textContent = state.radio.config.brand === 'rigctld' ? 'RIGCTLD' : (state.radio.config.model || 'RADIO');
  } else if (state.radio.config.brand !== 'none') {
    el.style.display = 'flex';
    el.classList.add('disconnected');
    el.querySelector('.radio-ind-label').textContent = 'RADIO OFF';
    document.getElementById('radio-ind-freq').textContent = '';
  } else {
    el.style.display = 'none';
  }
}

function updateRadioFreqDisplay() {
  if (!state.radio.connected) return;
  const freqEl = document.getElementById('radio-ind-freq');
  if (!freqEl) return;
  if (state.radio.lastSentDownlink > 0) {
    freqEl.textContent = (state.radio.lastSentDownlink / 1e6).toFixed(4) + ' MHz';
  }
}

// ============================================================
// STATE
// ============================================================
const state = {
  satellites: {},
  activeSatId: null,
  visibleSatIds: new Set(),
  observer: { lat: 39.7392, lon: -104.9903, alt: 0 },
  observerGd: null,
  settings: { minElevation: 5, updateInterval: 1000, baseMap: 'dark' },
  // Cesium state
  viewer: null,
  entities: {},       // { [nid]: { point, pastTrack, futureTrack } }
  footprintOuter: null,
  footprintInner: null,
  dopplerRings: null,
  observerEntity: null,
  losEntity: null,
  lastTerminatorTime: 0,
  imageryLayers: {},  // { radar, aurora, labels, nautical }
  trackingMode: false,
  lastCalcTime: 0, lastTrackTime: 0,
  nextPassCache: {}, animFrameId: null,
  // Radio CAT control state
  radio: {
    connected: false,
    transport: null,        // 'serial' | 'rigctld' | null
    protocol: null,         // 'icom' | 'yaesu_old' | 'yaesu_new' | 'kenwood' | null
    port: null,             // WebSerial port object
    reader: null,           // ReadableStream reader
    writer: null,           // WritableStream writer
    ws: null,               // WebSocket for rigctld
    config: {
      brand: 'none',       // 'icom' | 'yaesu' | 'kenwood' | 'rigctld' | 'none'
      model: '',
      baudRate: 9600,
      civAddress: 0x94,     // Icom CI-V address (varies by model)
      rigctldHost: 'localhost',
      wsPort: 4533,         // WebSocket bridge port
      dopplerCorrection: true,
      autoTune: true,
      splitVfo: false,      // true for full-duplex sats
    },
    lastTxTime: 0,          // throttle: last command send timestamp
    txInterval: 200,        // min ms between freq commands (5/sec)
    lastSentDownlink: 0,    // last frequency sent (avoid duplicate cmds)
    lastSentUplink: 0,
    rxBuffer: new Uint8Array(0),
  },
};

// ============================================================
// TLE FETCHING
// ============================================================
async function fetchTLEData(forceRefresh = false) {
  const cacheKey = 'sat_tracker_tle_v2';
  if (!forceRefresh) {
    try {
      const cached = JSON.parse(localStorage.getItem(cacheKey));
      if (cached && Date.now() - cached.timestamp < 24 * 3600 * 1000) {
        parseTLECache(cached.data);
        return true;
      }
    } catch (e) {}
  }

  const allTLEs = {};
  const fetches = CELESTRAK_GROUPS.map(async (group) => {
    try {
      const url = `https://celestrak.org/NORAD/elements/gp.php?GROUP=${group}&FORMAT=tle`;
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const text = await resp.text();
      const lines = text.trim().split('\n');
      for (let i = 0; i + 2 < lines.length; i += 3) {
        const name = lines[i].trim();
        const line1 = lines[i + 1].trim();
        const line2 = lines[i + 2].trim();
        if (line1.startsWith('1 ') && line2.startsWith('2 ')) {
          const noradId = parseInt(line2.substring(2, 7).trim());
          allTLEs[noradId] = { name, line1, line2 };
        }
      }
    } catch (e) {
      console.warn(`TLE group ${group} failed:`, e);
    }
  });

  await Promise.all(fetches);
  if (Object.keys(allTLEs).length === 0) throw new Error('No TLE data fetched');

  const missing = SATELLITE_CATALOG.filter(c => !allTLEs[c.noradId]);
  for (const sat of missing) {
    try {
      const resp = await fetch(`https://celestrak.org/NORAD/elements/gp.php?CATNR=${sat.noradId}&FORMAT=tle`);
      if (resp.ok) {
        const text = await resp.text();
        const lines = text.trim().split('\n');
        if (lines.length >= 3 && lines[1].startsWith('1 ')) {
          allTLEs[sat.noradId] = { name: lines[0].trim(), line1: lines[1].trim(), line2: lines[2].trim() };
        }
      }
    } catch (e) {}
  }

  try { localStorage.setItem(cacheKey, JSON.stringify({ timestamp: Date.now(), data: allTLEs })); } catch (e) {}
  parseTLECache(allTLEs);
  return true;
}

function parseTLECache(tleData) {
  for (const cat of SATELLITE_CATALOG) {
    const tle = tleData[cat.noradId];
    if (!tle) { console.warn(`TLE missing: ${cat.name} (${cat.noradId})`); continue; }
    try {
      const satrec = satellite.twoline2satrec(tle.line1, tle.line2);
      const epochYear = satrec.epochyr < 57 ? satrec.epochyr + 2000 : satrec.epochyr + 1900;
      const epochDate = new Date(Date.UTC(epochYear, 0, 1));
      epochDate.setUTCDate(epochDate.getUTCDate() + satrec.epochdays - 1);
      const ageHours = (Date.now() - epochDate.getTime()) / 3600000;

      state.satellites[cat.noradId] = {
        satrec, catalogEntry: cat, tle,
        position: null, lookAngles: null,
        rfVisible: false, visVisible: false,
        rangeRate: 0, signalLevel: 0,
        tleAgeHours: ageHours,
      };
    } catch (e) {
      console.warn(`TLE parse failed: ${cat.name}:`, e);
    }
  }
}

// ============================================================
// ORBITAL CALCULATIONS
// ============================================================
function getSatPosition(satrec, date) {
  const posVel = satellite.propagate(satrec, date);
  if (!posVel.position) return null;
  const gmst = satellite.gstime(date);
  const posGd = satellite.eciToGeodetic(posVel.position, gmst);
  return {
    lat: satellite.degreesLat(posGd.latitude),
    lon: satellite.degreesLong(posGd.longitude),
    alt: posGd.height,
    eci: posVel.position, vel: posVel.velocity, gmst,
  };
}

function getLookAngles(satrec, observerGd, date) {
  const posVel = satellite.propagate(satrec, date);
  if (!posVel.position) return null;
  const gmst = satellite.gstime(date);
  const ecf = satellite.eciToEcf(posVel.position, gmst);
  const look = satellite.ecfToLookAngles(observerGd, ecf);
  return { azimuth: look.azimuth * RAD2DEG, elevation: look.elevation * RAD2DEG, range: look.rangeSat };
}

function computeGroundTrack(satrec, now, pastMin, futureMin, stepSec) {
  const past = [], future = [];
  for (let off = -pastMin * 60; off <= futureMin * 60; off += stepSec) {
    const d = new Date(now.getTime() + off * 1000);
    const p = getSatPosition(satrec, d);
    if (!p) continue;
    const pt = [p.lat, p.lon];
    if (off <= 0) past.push(pt);
    if (off >= 0) future.push(pt);
  }
  return { pastTrack: past, futureTrack: future };
}

function getOrbitalPeriod(satrec) { return 2 * Math.PI / satrec.no; }

function getFootprintRadius(altKm) {
  return EARTH_R * Math.acos(EARTH_R / (EARTH_R + altKm));
}

function getFootprintRadiusAtElev(altKm, elevDeg) {
  const elevRad = elevDeg * DEG2RAD;
  const sinRho = EARTH_R / (EARTH_R + altKm);
  const eta = Math.acos(sinRho * Math.cos(elevRad)) - elevRad;
  return EARTH_R * eta;
}

// ============================================================
// VISIBILITY
// ============================================================
function isSatInSunlight(eci, date) {
  const jd = satellite.jday(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
  let sunEci;
  try {
    const sd = satellite.sunPosition(jd);
    sunEci = sd && sd.position ? sd.position : null;
  } catch (e) { sunEci = null; }
  if (!sunEci) return true;

  const s2s = { x: sunEci.x - eci.x, y: sunEci.y - eci.y, z: sunEci.z - eci.z };
  const s2e = { x: -eci.x, y: -eci.y, z: -eci.z };
  const sm = Math.sqrt(s2s.x ** 2 + s2s.y ** 2 + s2s.z ** 2);
  const em = Math.sqrt(s2e.x ** 2 + s2e.y ** 2 + s2e.z ** 2);
  if (sm === 0 || em === 0) return true;
  const dot = s2s.x * s2e.x + s2s.y * s2e.y + s2s.z * s2e.z;
  const angle = Math.acos(Math.max(-1, Math.min(1, dot / (sm * em))));
  return angle > Math.asin(Math.min(1, EARTH_R / em));
}

function isObserverDark(lat, lon, date) {
  return SunCalc.getPosition(date, lat, lon).altitude < -6 * DEG2RAD;
}

function computeVisualVis(sat, oGd, oLat, oLon, date) {
  const la = getLookAngles(sat.satrec, oGd, date);
  if (!la || la.elevation < 0) return false;
  const pv = satellite.propagate(sat.satrec, date);
  if (!pv.position) return false;
  return isSatInSunlight(pv.position, date) && isObserverDark(oLat, oLon, date);
}

// ============================================================
// NEXT PASS
// ============================================================
function findNextPass(satrec, oGd, minEl, start) {
  const step = 30, maxSteps = (24 * 3600) / step;
  let inPass = false, passStart = null, maxE = 0, maxEAz = 0;

  const cur = getLookAngles(satrec, oGd, start);
  if (cur && cur.elevation >= minEl) {
    for (let i = 0; i < 600; i++) {
      const d = new Date(start.getTime() + i * step * 1000);
      const la = getLookAngles(satrec, oGd, d);
      if (!la || la.elevation < minEl) { start = d; break; }
    }
  }

  for (let i = 0; i < maxSteps; i++) {
    const d = new Date(start.getTime() + i * step * 1000);
    const la = getLookAngles(satrec, oGd, d);
    if (!la) continue;
    if (la.elevation >= minEl && !inPass) { inPass = true; passStart = d; maxE = la.elevation; maxEAz = la.azimuth; }
    else if (la.elevation >= minEl && inPass && la.elevation > maxE) { maxE = la.elevation; maxEAz = la.azimuth; }
    else if (la.elevation < minEl && inPass) {
      return { start: passStart, end: d, maxEl: maxE, maxElAz: maxEAz, duration: (d - passStart) / 1000 };
    }
  }
  return null;
}

function findNextNPasses(satrec, oGd, minEl, start, count, hoursAhead) {
  const passes = [];
  let searchStart = new Date(start.getTime());
  const deadline = new Date(start.getTime() + (hoursAhead || 24) * 3600000);
  for (let n = 0; n < (count || 8); n++) {
    if (searchStart >= deadline) break;
    const p = findNextPass(satrec, oGd, minEl, searchStart);
    if (!p || p.start >= deadline) break;
    // Refine AOS/LOS with 1-second precision
    let aosDate = new Date(p.start.getTime() - 30000);
    for (let t = 0; t < 60; t++) {
      const d = new Date(aosDate.getTime() + t * 1000);
      const la = getLookAngles(satrec, oGd, d);
      if (la && la.elevation >= minEl) { p.start = d; p.aosAz = la.azimuth; break; }
    }
    let losDate = new Date(p.end.getTime() - 30000);
    for (let t = 0; t < 60; t++) {
      const d = new Date(losDate.getTime() + t * 1000);
      const la = getLookAngles(satrec, oGd, d);
      if (!la || la.elevation < minEl) { p.end = d; p.losAz = la.azimuth || 0; break; }
    }
    p.duration = (p.end - p.start) / 1000;
    passes.push(p);
    searchStart = new Date(p.end.getTime() + 60000);
  }
  return passes;
}

// ============================================================
// CESIUM — HELPER: Color from hex
// ============================================================
function hexToColor(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;
  return new Cesium.Color(r, g, b, alpha !== undefined ? alpha : 1.0);
}

// ============================================================
// CESIUM — MAP INIT
// ============================================================
function initMap() {
  // Cesium Ion not needed — disable default token
  Cesium.Ion.defaultAccessToken = undefined;

  state.viewer = new Cesium.Viewer('cesiumContainer', {
    baseLayer: false,
    baseLayerPicker: false,
    geocoder: false,
    homeButton: false,
    sceneModePicker: false,
    selectionIndicator: false,
    timeline: false,
    animation: false,
    fullscreenButton: false,
    vrButton: false,
    navigationHelpButton: false,
    infoBox: false,
    creditContainer: document.createElement('div'), // hide credits
    skyBox: false,
    skyAtmosphere: new Cesium.SkyAtmosphere(),
    contextOptions: {
      webgl: { alpha: false },
    },
  });

  const viewer = state.viewer;
  const scene = viewer.scene;

  // Dark space background
  scene.backgroundColor = new Cesium.Color(0.04, 0.055, 0.08, 1.0);

  // Disable Cesium built-in lighting (too aggressive on dark tiles).
  // We draw our own terminator overlay for a subtle day/night effect.
  scene.globe.enableLighting = false;

  // Globe appearance
  scene.globe.baseColor = new Cesium.Color(0.10, 0.12, 0.18, 1.0);
  scene.globe.showGroundAtmosphere = true;
  scene.fog.enabled = false;

  // Add dark CartoDB tiles as base imagery
  applyBaseMap(state.settings.baseMap || 'dark');

  // Observer entity
  state.observerEntity = viewer.entities.add({
    position: Cesium.Cartesian3.fromDegrees(state.observer.lon, state.observer.lat, 0),
    point: {
      pixelSize: 10,
      color: hexToColor('#4da6ff'),
      outlineColor: Cesium.Color.WHITE,
      outlineWidth: 2,
      heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
      disableDepthTestDistance: Number.POSITIVE_INFINITY,
    },
    label: {
      text: 'QTH',
      font: '11px monospace',
      fillColor: hexToColor('#4da6ff'),
      outlineColor: Cesium.Color.BLACK,
      outlineWidth: 2,
      style: Cesium.LabelStyle.FILL_AND_OUTLINE,
      verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
      pixelOffset: new Cesium.Cartesian2(0, -14),
      heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
      disableDepthTestDistance: Number.POSITIVE_INFINITY,
    },
  });

  // LOS line entity (observer → satellite, shown when above horizon)
  state.losEntity = viewer.entities.add({
    polyline: {
      positions: [],
      width: 1,
      material: new Cesium.PolylineDashMaterialProperty({
        color: new Cesium.Color(0.3, 1.0, 0.3, 0.4),
        dashLength: 8,
      }),
      show: false,
    },
  });

  // Terminator overlay — canvas-based imagery layer (avoids polygon geometry issues)
  initTerminatorOverlay();

  // Initial camera view — global
  viewer.camera.setView({
    destination: Cesium.Cartesian3.fromDegrees(0, 20, 25000000),
  });

  // Disable default double-click entity tracking
  viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

  // Start loading overlay data
  loadRainViewerRadar();
  loadAuroraData();
  setInterval(loadRainViewerRadar, 5 * 60 * 1000);
  setInterval(loadAuroraData, 10 * 60 * 1000);
}

// ============================================================
// TERMINATOR OVERLAY (canvas-based imagery layer)
// ============================================================
const TERM_CANVAS_W = 360;
const TERM_CANVAS_H = 180;
let terminatorCanvas = null;
let terminatorCtx = null;
let terminatorLayer = null;

function getSubsolarPoint(date) {
  // Days since J2000.0 (2000-01-01 12:00 TT)
  const T = (date.getTime() / 86400000) - 10957.5;
  const L0 = (280.460 + 0.9856474 * T) % 360;
  const M = ((357.528 + 0.9856003 * T) % 360) * Math.PI / 180;
  const eclLon = (L0 + 1.915 * Math.sin(M) + 0.020 * Math.sin(2 * M)) * Math.PI / 180;
  const obliquity = 23.439 * Math.PI / 180;
  const decl = Math.asin(Math.sin(obliquity) * Math.sin(eclLon));
  const ra = Math.atan2(Math.cos(obliquity) * Math.sin(eclLon), Math.cos(eclLon));
  const gmst = satellite.gstime(satellite.jday(
    date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(),
    date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds()
  ));
  let lon = ((ra - gmst) * 180 / Math.PI) % 360;
  if (lon > 180) lon -= 360;
  if (lon < -180) lon += 360;
  return { lat: decl * 180 / Math.PI, lon: lon };
}

function initTerminatorOverlay() {
  terminatorCanvas = document.createElement('canvas');
  terminatorCanvas.width = TERM_CANVAS_W;
  terminatorCanvas.height = TERM_CANVAS_H;
  terminatorCtx = terminatorCanvas.getContext('2d');
  paintTerminator(new Date());

  const provider = new Cesium.SingleTileImageryProvider({
    url: terminatorCanvas.toDataURL(),
    rectangle: Cesium.Rectangle.fromDegrees(-180, -90, 180, 90),
  });
  terminatorLayer = state.viewer.imageryLayers.addImageryProvider(provider);
  terminatorLayer.alpha = 0.55;
}

function paintTerminator(date) {
  if (!terminatorCtx) return;
  const ctx = terminatorCtx;
  const w = TERM_CANVAS_W;
  const h = TERM_CANVAS_H;
  const sub = getSubsolarPoint(date);

  ctx.clearRect(0, 0, w, h);

  const DEG = Math.PI / 180;
  const subLatR = sub.lat * DEG;
  const subLonR = sub.lon * DEG;

  // For each pixel, compute angular distance from subsolar point
  // If > 90° → night (dark), with smooth gradient near terminator
  const imgData = ctx.createImageData(w, h);
  const data = imgData.data;

  for (let y = 0; y < h; y++) {
    const lat = (90 - y) * DEG; // pixel row → latitude in radians
    const sinLat = Math.sin(lat);
    const cosLat = Math.cos(lat);
    for (let x = 0; x < w; x++) {
      const lon = (x - 180) * DEG; // pixel col → longitude in radians
      // Angular distance from subsolar point (spherical law of cosines)
      const cosAngle = sinLat * Math.sin(subLatR) + cosLat * Math.cos(subLatR) * Math.cos(lon - subLonR);
      // cosAngle > 0 → day, < 0 → night; 0 = terminator
      // Smooth transition over ~6° (twilight zone)
      const twilightWidth = 0.10; // ~6° in cosine space
      let nightFactor;
      if (cosAngle > twilightWidth) {
        nightFactor = 0; // full day
      } else if (cosAngle < -twilightWidth) {
        nightFactor = 1; // full night
      } else {
        nightFactor = 0.5 - (cosAngle / (2 * twilightWidth)); // smooth gradient
      }

      const idx = (y * w + x) * 4;
      data[idx]     = 0;   // R
      data[idx + 1] = 2;   // G
      data[idx + 2] = 12;  // B
      data[idx + 3] = Math.round(nightFactor * 255); // A
    }
  }
  ctx.putImageData(imgData, 0, 0);
}

function updateTerminator(date) {
  if (!terminatorCanvas || !terminatorLayer) return;
  paintTerminator(date);
  // Update the imagery layer by swapping the provider
  const viewer = state.viewer;
  const alpha = terminatorLayer.alpha;
  const idx = viewer.imageryLayers.indexOf(terminatorLayer);
  viewer.imageryLayers.remove(terminatorLayer, false);
  const provider = new Cesium.SingleTileImageryProvider({
    url: terminatorCanvas.toDataURL(),
    rectangle: Cesium.Rectangle.fromDegrees(-180, -90, 180, 90),
  });
  terminatorLayer = viewer.imageryLayers.addImageryProvider(provider, idx);
  terminatorLayer.alpha = alpha;
}

// ============================================================
// CESIUM — BASE MAP SWITCHING
// ============================================================
function applyBaseMap(mapId) {
  const viewer = state.viewer;
  // Remove all current imagery layers
  viewer.imageryLayers.removeAll();

  let provider;
  switch (mapId) {
    case 'dark-labels':
      provider = new Cesium.UrlTemplateImageryProvider({
        url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
        subdomains: 'abcd',
        maximumLevel: 18,
        credit: 'CartoDB',
      });
      break;
    case 'satellite':
      provider = new Cesium.UrlTemplateImageryProvider({
        url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        maximumLevel: 18,
        credit: 'ESRI',
      });
      break;
    case 'terrain':
      provider = new Cesium.UrlTemplateImageryProvider({
        url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
        subdomains: 'abc',
        maximumLevel: 17,
        credit: 'OpenTopoMap',
      });
      break;
    case 'dark':
    default:
      provider = new Cesium.UrlTemplateImageryProvider({
        url: 'https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}.png',
        subdomains: 'abcd',
        maximumLevel: 18,
        credit: 'CartoDB',
      });
      break;
  }

  const baseLayer = viewer.imageryLayers.addImageryProvider(provider);
  // Slight brightness boost for dark tiles
  baseLayer.brightness = 1.3;
  baseLayer.contrast = 1.05;
  baseLayer.gamma = 0.95;

  // Re-add any active overlays on top
  reapplyOverlays();
}

function reapplyOverlays() {
  // Re-add overlay layers that are toggled on
  const overlayIds = ['radar', 'aurora', 'labels', 'nautical'];
  for (const id of overlayIds) {
    if (state.imageryLayers[id]) {
      const layer = state.imageryLayers[id];
      // Check if layer is still in the collection
      if (state.viewer.imageryLayers.indexOf(layer) === -1) {
        // Layer was removed — recreate if toggle is on
        const cb = document.getElementById('overlay-' + id);
        if (cb && cb.checked) {
          toggleOverlay(id, true);
        } else {
          state.imageryLayers[id] = null;
        }
      }
    }
  }
}

// ============================================================
// OVERLAY MANAGEMENT
// ============================================================
function toggleOverlay(id, on) {
  const viewer = state.viewer;

  // Remove existing layer if any
  if (state.imageryLayers[id]) {
    viewer.imageryLayers.remove(state.imageryLayers[id], false);
    state.imageryLayers[id] = null;
  }

  // Special case: terminator
  if (id === 'terminator') {
    if (terminatorLayer) {
      viewer.imageryLayers.remove(terminatorLayer, false);
      terminatorLayer = null;
    }
    if (on) initTerminatorOverlay();
    return;
  }

  if (!on) return;

  let provider;
  switch (id) {
    case 'labels':
      provider = new Cesium.UrlTemplateImageryProvider({
        url: 'https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}.png',
        subdomains: 'abcd',
        maximumLevel: 18,
      });
      break;
    case 'nautical':
      provider = new Cesium.UrlTemplateImageryProvider({
        url: 'https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png',
        maximumLevel: 18,
      });
      break;
    case 'radar':
      loadRainViewerRadar(true);
      return;
    case 'aurora':
      loadAuroraData(true);
      return;
    case 'gridsquares':
      createGridSquareOverlay();
      return;
    case 'muf':
      loadMufOverlay();
      return;
    case 'grayline':
      createGrayLineOverlay();
      return;
  }

  if (provider) {
    const layer = viewer.imageryLayers.addImageryProvider(provider);
    layer.alpha = id === 'nautical' ? 0.7 : 1.0;
    state.imageryLayers[id] = layer;
  }
}

// ============================================================
// RAINVIEWER RADAR OVERLAY
// ============================================================
async function loadRainViewerRadar(force) {
  if (!force) {
    const cb = document.getElementById('overlay-radar');
    if (!cb || !cb.checked) return;
  }

  try {
    const resp = await fetch('https://api.rainviewer.com/public/weather-maps.json');
    if (!resp.ok) return;
    const data = await resp.json();
    const frames = data.radar && data.radar.past;
    if (!frames || frames.length === 0) return;
    const latest = frames[frames.length - 1];
    const host = data.host || 'https://tilecache.rainviewer.com';
    const tileUrl = `${host}${latest.path}/256/{z}/{x}/{y}/6/1_1.png`;

    // Remove old radar layer
    if (state.imageryLayers.radar) {
      state.viewer.imageryLayers.remove(state.imageryLayers.radar, false);
    }

    const provider = new Cesium.UrlTemplateImageryProvider({
      url: tileUrl,
      maximumLevel: 18,
    });
    const layer = state.viewer.imageryLayers.addImageryProvider(provider);
    layer.alpha = 0.55;
    state.imageryLayers.radar = layer;
  } catch (e) {
    console.warn('RainViewer load failed:', e);
  }
}

// ============================================================
// NOAA AURORA OVERLAY
// ============================================================
async function loadAuroraData(force) {
  if (!force) {
    const cb = document.getElementById('overlay-aurora');
    if (!cb || !cb.checked) return;
  }

  try {
    const resp = await fetch('https://services.swpc.noaa.gov/json/ovation_aurora_latest.json');
    if (!resp.ok) return;
    const data = await resp.json();
    const coords = data.coordinates || data;
    if (!Array.isArray(coords) || coords.length === 0) return;

    // Render aurora to a canvas and use as SingleTileImageryProvider
    const canvas = document.createElement('canvas');
    canvas.width = 720;   // 2 pixels per degree longitude
    canvas.height = 360;  // 2 pixels per degree latitude
    const ctx = canvas.getContext('2d');

    for (const point of coords) {
      let lon = point[0] > 180 ? point[0] - 360 : point[0];
      const lat = point[1];
      const intensity = point[2];
      if (intensity < 10) continue;

      // Map to canvas coords
      const x = (lon + 180) * 2;
      const y = (90 - lat) * 2;

      // Color based on intensity
      if (intensity < 20) ctx.fillStyle = 'rgba(0, 120, 50, 0.4)';
      else if (intensity < 35) ctx.fillStyle = 'rgba(0, 200, 50, 0.5)';
      else if (intensity < 55) ctx.fillStyle = 'rgba(50, 255, 50, 0.6)';
      else if (intensity < 75) ctx.fillStyle = 'rgba(100, 255, 100, 0.7)';
      else ctx.fillStyle = 'rgba(150, 255, 150, 0.8)';

      ctx.fillRect(x - 1, y - 1, 3, 3);
    }

    // Remove old aurora layer
    if (state.imageryLayers.aurora) {
      state.viewer.imageryLayers.remove(state.imageryLayers.aurora, false);
    }

    const provider = new Cesium.SingleTileImageryProvider({
      url: canvas.toDataURL(),
      rectangle: Cesium.Rectangle.fromDegrees(-180, -90, 180, 90),
    });
    const layer = state.viewer.imageryLayers.addImageryProvider(provider);
    layer.alpha = 0.7;
    state.imageryLayers.aurora = layer;
  } catch (e) {
    console.warn('Aurora data load failed:', e);
  }
}

// ============================================================
// HAM RADIO — MAIDENHEAD GRID SQUARE OVERLAY
// ============================================================
function createGridSquareOverlay() {
  // Use a much higher resolution canvas for crisp, bold labels
  const canvas = document.createElement('canvas');
  canvas.width = 2160;  // 6px per degree longitude (3x previous)
  canvas.height = 1080; // 6px per degree latitude
  const ctx = canvas.getContext('2d');
  const pxPerDegLon = canvas.width / 360;
  const pxPerDegLat = canvas.height / 180;

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const fieldLetters = 'ABCDEFGHIJKLMNOPQR';

  // Draw Maidenhead field grid (18 x 18 fields, each 20° lon x 10° lat)
  for (let fi = 0; fi < 18; fi++) {
    for (let fj = 0; fj < 18; fj++) {
      const lonDeg = fi * 20 - 180;
      const latDeg = fj * 10 - 90;
      const x = (lonDeg + 180) * pxPerDegLon;
      const y = (90 - latDeg - 10) * pxPerDegLat;
      const w = 20 * pxPerDegLon;
      const h = 10 * pxPerDegLat;

      // Field border — bold, clearly visible
      ctx.strokeStyle = 'rgba(0, 229, 255, 0.45)';
      ctx.lineWidth = 2.5;
      ctx.strokeRect(x, y, w, h);

      // Field label — BIG and BOLD (e.g., AA, AB, ..., RR)
      const label = fieldLetters[fi] + fieldLetters[fj];

      // Label background for readability
      ctx.fillStyle = 'rgba(10, 14, 20, 0.5)';
      const labelW = 38;
      const labelH = 22;
      ctx.fillRect(x + w / 2 - labelW / 2, y + h / 2 - labelH / 2, labelW, labelH);

      ctx.fillStyle = 'rgba(0, 229, 255, 0.85)';
      ctx.font = 'bold 24px monospace';
      ctx.fillText(label, x + w / 2, y + h / 2 + 1);

      // Sub-grid (10 squares per field: 2° lon x 1° lat each)
      ctx.strokeStyle = 'rgba(0, 229, 255, 0.12)';
      ctx.lineWidth = 0.8;
      for (let si = 1; si < 10; si++) {
        const sx = x + si * (w / 10);
        ctx.beginPath(); ctx.moveTo(sx, y); ctx.lineTo(sx, y + h); ctx.stroke();
      }
      for (let sj = 1; sj < 10; sj++) {
        const sy = y + sj * (h / 10);
        ctx.beginPath(); ctx.moveTo(x, sy); ctx.lineTo(x + w, sy); ctx.stroke();
      }

      // Sub-square number labels (0-9 on edges, smaller but still visible)
      ctx.fillStyle = 'rgba(0, 229, 255, 0.3)';
      ctx.font = 'bold 11px monospace';
      for (let si = 0; si < 10; si++) {
        const sx = x + si * (w / 10) + (w / 20);
        ctx.fillText(si.toString(), sx, y + 8);
      }
      for (let sj = 0; sj < 10; sj++) {
        const sy = y + sj * (h / 10) + (h / 20);
        ctx.fillText(sj.toString(), x + 8, sy);
      }
    }
  }

  const provider = new Cesium.SingleTileImageryProvider({
    url: canvas.toDataURL(),
    rectangle: Cesium.Rectangle.fromDegrees(-180, -90, 180, 90),
  });
  const layer = state.viewer.imageryLayers.addImageryProvider(provider);
  layer.alpha = 0.85;
  state.imageryLayers.gridsquares = layer;
}

// ============================================================
// HAM RADIO — MUF / PROPAGATION MAP
// ============================================================
async function loadMufOverlay() {
  // Use KC2G PropMap for real-time MUF data (Maximum Usable Frequency)
  try {
    const canvas = document.createElement('canvas');
    canvas.width = 720;
    canvas.height = 360;
    const ctx = canvas.getContext('2d');

    // Compute a simulated MUF map based on subsolar point and time of day
    // Real MUF depends on ionospheric F2 layer critical frequency
    const date = new Date();
    const sub = getSubsolarPoint(date);
    const DEG = Math.PI / 180;
    const subLatR = sub.lat * DEG;
    const subLonR = sub.lon * DEG;

    for (let y = 0; y < 360; y++) {
      const lat = (90 - y / 2) * DEG;
      const sinLat = Math.sin(lat);
      const cosLat = Math.cos(lat);
      for (let x = 0; x < 720; x++) {
        const lon = (x / 2 - 180) * DEG;
        // Solar zenith angle
        const cosZenith = sinLat * Math.sin(subLatR) + cosLat * Math.cos(subLatR) * Math.cos(lon - subLonR);
        // MUF approximation: higher on day side, peaks near subsolar, drops at night
        // Typical range: 3-30 MHz
        let mufNorm;
        if (cosZenith > 0.1) {
          mufNorm = 0.3 + 0.7 * Math.pow(cosZenith, 0.5); // day side
        } else if (cosZenith > -0.1) {
          mufNorm = 0.2 + 0.3 * (cosZenith + 0.1) / 0.2; // twilight
        } else {
          mufNorm = 0.05 + 0.15 * Math.max(0, 1 + cosZenith * 3); // night side
        }
        // Latitude factor — MUF higher at equator/low latitudes
        const latFactor = Math.cos(lat) * 0.3 + 0.7;
        mufNorm *= latFactor;

        // Color: blue (low MUF) → green → yellow → red (high MUF)
        let r, g, b;
        if (mufNorm < 0.25) {
          r = 0; g = 0; b = Math.round(100 * mufNorm / 0.25);
        } else if (mufNorm < 0.5) {
          const t = (mufNorm - 0.25) / 0.25;
          r = 0; g = Math.round(180 * t); b = Math.round(100 * (1 - t));
        } else if (mufNorm < 0.75) {
          const t = (mufNorm - 0.5) / 0.25;
          r = Math.round(200 * t); g = Math.round(180); b = 0;
        } else {
          const t = (mufNorm - 0.75) / 0.25;
          r = Math.round(200 + 55 * t); g = Math.round(180 * (1 - t * 0.6)); b = 0;
        }

        const idx = (y * 720 + x) * 4;
        const imgData = ctx.getImageData(x, y, 1, 1);
        imgData.data[0] = r;
        imgData.data[1] = g;
        imgData.data[2] = b;
        imgData.data[3] = Math.round(mufNorm * 120); // semi-transparent
        ctx.putImageData(imgData, x, y);
      }
    }

    // Add legend labels
    ctx.font = 'bold 10px monospace';
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.textAlign = 'left';
    ctx.fillText('MUF HIGH', 10, 20);
    ctx.fillStyle = 'rgba(255,200,0,0.6)';
    ctx.fillRect(85, 12, 30, 10);
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.fillText('LOW', 10, 345);
    ctx.fillStyle = 'rgba(0,0,100,0.6)';
    ctx.fillRect(40, 337, 30, 10);

    const provider = new Cesium.SingleTileImageryProvider({
      url: canvas.toDataURL(),
      rectangle: Cesium.Rectangle.fromDegrees(-180, -90, 180, 90),
    });
    const layer = state.viewer.imageryLayers.addImageryProvider(provider);
    layer.alpha = 0.5;
    state.imageryLayers.muf = layer;
  } catch (e) {
    console.warn('MUF overlay failed:', e);
  }
}

// ============================================================
// HAM RADIO — GRAY LINE OVERLAY
// ============================================================
function createGrayLineOverlay() {
  // The gray line (twilight zone) is the band around the terminator
  // where HF propagation is enhanced — signals travel along the terminator
  const canvas = document.createElement('canvas');
  canvas.width = 720;
  canvas.height = 360;
  const ctx = canvas.getContext('2d');

  const date = new Date();
  const sub = getSubsolarPoint(date);
  const DEG = Math.PI / 180;
  const subLatR = sub.lat * DEG;
  const subLonR = sub.lon * DEG;

  const imgData = ctx.createImageData(720, 360);
  const data = imgData.data;

  for (let y = 0; y < 360; y++) {
    const lat = (90 - y / 2) * DEG;
    const sinLat = Math.sin(lat);
    const cosLat = Math.cos(lat);
    for (let x = 0; x < 720; x++) {
      const lon = (x / 2 - 180) * DEG;
      const cosAngle = sinLat * Math.sin(subLatR) + cosLat * Math.cos(subLatR) * Math.cos(lon - subLonR);
      // Gray line: the band where cosAngle is near 0 (terminator ± ~10°)
      const dist = Math.abs(cosAngle); // distance from terminator
      let intensity;
      if (dist < 0.05) {
        intensity = 1.0; // right on the terminator — strongest
      } else if (dist < 0.18) {
        intensity = Math.max(0, 1.0 - (dist - 0.05) / 0.13); // fade out
      } else {
        intensity = 0;
      }

      if (intensity > 0) {
        const idx = (y * 720 + x) * 4;
        data[idx]     = 255; // R — golden glow
        data[idx + 1] = 180;
        data[idx + 2] = 50;
        data[idx + 3] = Math.round(intensity * 120);
      }
    }
  }
  ctx.putImageData(imgData, 0, 0);

  const provider = new Cesium.SingleTileImageryProvider({
    url: canvas.toDataURL(),
    rectangle: Cesium.Rectangle.fromDegrees(-180, -90, 180, 90),
  });
  const layer = state.viewer.imageryLayers.addImageryProvider(provider);
  layer.alpha = 0.6;
  state.imageryLayers.grayline = layer;
}

// ============================================================
// CESIUM — SATELLITE ENTITIES
// ============================================================
function addSatMarker(nid) {
  if (state.entities[nid]) return;
  const sat = state.satellites[nid];
  if (!sat) return;
  const c = sat.catalogEntry;
  const col = hexToColor(c.color);
  const isActive = nid === state.activeSatId;
  const viewer = state.viewer;

  // Satellite point at orbital altitude
  const pointEntity = viewer.entities.add({
    position: Cesium.Cartesian3.fromDegrees(0, 0, 400000), // placeholder
    point: {
      pixelSize: isActive ? 12 : 7,
      color: col,
      outlineColor: Cesium.Color.WHITE.withAlpha(0.7),
      outlineWidth: isActive ? 2 : 1,
      disableDepthTestDistance: Number.POSITIVE_INFINITY,
    },
    label: {
      text: c.name,
      font: '10px monospace',
      fillColor: col,
      outlineColor: Cesium.Color.BLACK,
      outlineWidth: 2,
      style: Cesium.LabelStyle.FILL_AND_OUTLINE,
      verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
      pixelOffset: new Cesium.Cartesian2(0, -12),
      show: isActive,
      disableDepthTestDistance: Number.POSITIVE_INFINITY,
    },
  });

  // Past track (dashed, on ground surface)
  const pastTrack = viewer.entities.add({
    polyline: {
      positions: [],
      width: isActive ? 2 : 1.5,
      material: new Cesium.PolylineDashMaterialProperty({
        color: col.withAlpha(0.25),
        dashLength: 8,
      }),
      clampToGround: true,
    },
  });

  // Future track (solid, on ground surface)
  const futureTrack = viewer.entities.add({
    polyline: {
      positions: [],
      width: isActive ? 2.5 : 1.5,
      material: col.withAlpha(isActive ? 0.6 : 0.3),
      clampToGround: true,
    },
  });

  state.entities[nid] = { point: pointEntity, pastTrack, futureTrack, dopplerSegments: [] };
}

function removeSatMarker(nid) {
  const ents = state.entities[nid];
  if (!ents) return;
  const viewer = state.viewer;
  viewer.entities.remove(ents.point);
  viewer.entities.remove(ents.pastTrack);
  viewer.entities.remove(ents.futureTrack);
  if (ents.dopplerSegments) ents.dopplerSegments.forEach(s => viewer.entities.remove(s));
  delete state.entities[nid];
}

function updateSatEntityStyle(nid, isActive) {
  const ents = state.entities[nid];
  if (!ents) return;
  const sat = state.satellites[nid];
  if (!sat) return;
  const col = hexToColor(sat.catalogEntry.color);

  ents.point.point.pixelSize = isActive ? 12 : 7;
  ents.point.point.outlineWidth = isActive ? 2 : 1;
  ents.point.label.show = isActive;

  ents.pastTrack.polyline.width = isActive ? 2 : 1.5;
  ents.futureTrack.polyline.width = isActive ? 2.5 : 1.5;
  ents.futureTrack.polyline.material = col.withAlpha(isActive ? 0.6 : 0.3);
}

// ============================================================
// CESIUM — GROUND TRACKS (no antimeridian splitting needed!)
// ============================================================
function dopplerShiftToColor(shiftHz, maxShift) {
  // Exaggerate by squaring to make subtle shifts more visible
  const raw = Math.max(-1, Math.min(1, shiftHz / maxShift));
  const t = Math.sign(raw) * Math.pow(Math.abs(raw), 0.5);
  if (t > 0.05) {
    // Approaching: vivid orange/red
    const s = Math.min(1, t * 1.5);
    return new Cesium.Color(1.0, 0.4 * (1 - s) + 0.25 * s, 0.1 * (1 - s), 0.9);
  } else if (t < -0.05) {
    // Receding: vivid blue/cyan
    const s = Math.min(1, Math.abs(t) * 1.5);
    return new Cesium.Color(0.15 * (1 - s), 0.5 * (1 - s) + 0.3 * s, 1.0, 0.9);
  } else {
    // Near zero shift: white
    return new Cesium.Color(1.0, 1.0, 1.0, 0.8);
  }
}

function updateTracks(nid, now) {
  const sat = state.satellites[nid];
  const ents = state.entities[nid];
  if (!sat || !ents) return;
  const viewer = state.viewer;
  const isActive = nid === state.activeSatId;

  const period = getOrbitalPeriod(sat.satrec);
  const { pastTrack, futureTrack } = computeGroundTrack(sat.satrec, now, period, period * 1.5, 30);

  // Convert [lat, lon] arrays to Cesium Cartesian3 — NOTE: lon/lat swap!
  if (pastTrack.length > 1) {
    const pastDegrees = [];
    for (const pt of pastTrack) { pastDegrees.push(pt[1], pt[0]); }
    ents.pastTrack.polyline.positions = Cesium.Cartesian3.fromDegreesArray(pastDegrees);
  } else {
    ents.pastTrack.polyline.positions = [];
  }

  // Remove old Doppler segments
  if (ents.dopplerSegments) {
    ents.dopplerSegments.forEach(s => viewer.entities.remove(s));
    ents.dopplerSegments = [];
  }

  if (futureTrack.length > 1 && isActive && state.observerGd) {
    // Hide the default future track — we'll draw Doppler-colored segments instead
    ents.futureTrack.polyline.positions = [];

    // Compute Doppler at each future track point
    const points = futureTrack.map((pt, i) => {
      const d = new Date(now.getTime() + i * 30 * 1000);
      const rr = getRangeRate(sat.satrec, state.observerGd, d);
      const freq = sat.catalogEntry.downlink || 437;
      const shiftHz = computeDoppler(freq, rr) * 1000;
      return { lat: pt[0], lon: pt[1], shiftHz };
    });

    // Find max shift for color scaling
    const maxShift = Math.max(500, ...points.map(p => Math.abs(p.shiftHz)));

    // Draw colored segments (pairs of adjacent points)
    for (let i = 0; i < points.length - 1; i++) {
      const p1 = points[i], p2 = points[i + 1];
      const avgShift = (p1.shiftHz + p2.shiftHz) / 2;
      const col = dopplerShiftToColor(avgShift, maxShift);
      const seg = viewer.entities.add({
        polyline: {
          positions: Cesium.Cartesian3.fromDegreesArray([p1.lon, p1.lat, p2.lon, p2.lat]),
          width: 3.5,
          material: col,
          clampToGround: true,
        },
      });
      ents.dopplerSegments.push(seg);
    }
  } else if (futureTrack.length > 1) {
    const futureDegrees = [];
    for (const pt of futureTrack) { futureDegrees.push(pt[1], pt[0]); }
    ents.futureTrack.polyline.positions = Cesium.Cartesian3.fromDegreesArray(futureDegrees);
  } else {
    ents.futureTrack.polyline.positions = [];
  }
}

// ============================================================
// CESIUM — FOOTPRINTS
// ============================================================
function updateFootprint(pos) {
  const viewer = state.viewer;

  // Remove old footprints
  if (state.footprintOuter) { viewer.entities.remove(state.footprintOuter); state.footprintOuter = null; }
  if (state.footprintInner) { viewer.entities.remove(state.footprintInner); state.footprintInner = null; }
  if (!pos || state.activeSatId == null) return;

  const sat = state.satellites[state.activeSatId];
  if (!sat) return;
  const col = hexToColor(sat.catalogEntry.color);

  // Outer ring: 0° elevation (horizon footprint)
  const r0 = getFootprintRadius(pos.alt) * 1000; // meters
  state.footprintOuter = viewer.entities.add({
    position: Cesium.Cartesian3.fromDegrees(pos.lon, pos.lat),
    ellipse: {
      semiMajorAxis: r0,
      semiMinorAxis: r0,
      height: 0,
      material: col.withAlpha(0.04),
      outline: true,
      outlineColor: col.withAlpha(0.2),
      outlineWidth: 1,
    },
  });

  // Inner ring: min elevation footprint
  const rMin = getFootprintRadiusAtElev(pos.alt, state.settings.minElevation) * 1000;
  state.footprintInner = viewer.entities.add({
    position: Cesium.Cartesian3.fromDegrees(pos.lon, pos.lat),
    ellipse: {
      semiMajorAxis: rMin,
      semiMinorAxis: rMin,
      height: 0,
      material: col.withAlpha(0.06),
      outline: true,
      outlineColor: col.withAlpha(0.4),
      outlineWidth: 2,
    },
  });
}

// ============================================================
// CESIUM — DOPPLER WAVEFRONT RINGS
// ============================================================
function updateDopplerRings(pos) {
  const viewer = state.viewer;
  // Remove old rings
  if (state.dopplerRings) {
    state.dopplerRings.forEach(r => viewer.entities.remove(r));
    state.dopplerRings = null;
  }
  if (!pos || state.activeSatId == null) return;
  const sat = state.satellites[state.activeSatId];
  if (!sat || !state.observerGd) return;

  const rr = sat.rangeRate || 0;
  if (Math.abs(rr) < 0.01) return;

  const approaching = rr < 0;
  const speed = Math.abs(rr);

  const rings = [];
  const altM = pos.alt * 1000;
  // Layered filled rings — outer rings first (larger, more transparent),
  // inner rings on top (smaller, more opaque) to create gradient effect
  const numRings = 5;
  const maxRadius = 800000; // 800km outer radius

  for (let i = numRings; i >= 1; i--) {
    const frac = i / numRings;
    const radius = maxRadius * frac;
    // Alpha fades out toward edges: inner = vivid, outer = faint
    const alpha = approaching
      ? 0.06 + 0.14 * (1 - frac)  // orange layers
      : 0.05 + 0.12 * (1 - frac); // blue layers
    const col = approaching
      ? new Cesium.Color(1.0, 0.35, 0.05, alpha)
      : new Cesium.Color(0.15, 0.45, 1.0, alpha);

    const ring = viewer.entities.add({
      position: Cesium.Cartesian3.fromDegrees(pos.lon, pos.lat, altM),
      ellipse: {
        semiMajorAxis: radius,
        semiMinorAxis: radius,
        height: altM,
        material: col,
        outline: i === numRings, // outline only on outermost ring
        outlineColor: approaching
          ? new Cesium.Color(1.0, 0.4, 0.1, 0.35)
          : new Cesium.Color(0.2, 0.5, 1.0, 0.35),
        outlineWidth: 1.5,
      },
    });
    rings.push(ring);
  }

  // Center glow — small bright dot right at satellite
  const glow = viewer.entities.add({
    position: Cesium.Cartesian3.fromDegrees(pos.lon, pos.lat, altM),
    ellipse: {
      semiMajorAxis: 80000,
      semiMinorAxis: 80000,
      height: altM,
      material: approaching
        ? new Cesium.Color(1.0, 0.5, 0.15, 0.3)
        : new Cesium.Color(0.3, 0.6, 1.0, 0.3),
      outline: false,
    },
  });
  rings.push(glow);

  state.dopplerRings = rings;
}

// ============================================================
// CESIUM — LOS LINE (observer → satellite)
// ============================================================
function updateLosLine(pos) {
  const losEntity = state.losEntity;
  if (!pos || state.activeSatId == null) {
    losEntity.polyline.show = false;
    document.getElementById('los-legend').style.display = 'none';
    return;
  }
  const sat = state.satellites[state.activeSatId];
  if (!sat || !sat.lookAngles || sat.lookAngles.elevation < 0) {
    losEntity.polyline.show = false;
    document.getElementById('los-legend').style.display = 'none';
    return;
  }

  // Observer position on surface → Satellite position at altitude
  losEntity.polyline.positions = [
    Cesium.Cartesian3.fromDegrees(state.observer.lon, state.observer.lat, (state.observer.alt || 0)),
    Cesium.Cartesian3.fromDegrees(pos.lon, pos.lat, pos.alt * 1000),
  ];
  losEntity.polyline.show = true;
  document.getElementById('los-legend').style.display = 'block';
}

// ============================================================
// OBSERVER
// ============================================================
function setObserverLocation(lat, lon, altM) {
  const cc = state.observer?.countryCode || '';
  const pn = state.observer?.placeName || '';
  const cs = state.observer?.callsign || '';
  state.observer = { lat, lon, alt: altM || 0, countryCode: cc, placeName: pn, callsign: cs };
  state.observerGd = { longitude: satellite.degreesToRadians(lon), latitude: satellite.degreesToRadians(lat), height: (altM || 0) / 1000 };
  localStorage.setItem('sat_tracker_observer', JSON.stringify(state.observer));

  // Update Cesium observer entity
  if (state.observerEntity) {
    state.observerEntity.position = Cesium.Cartesian3.fromDegrees(lon, lat, 0);
  }

  updateObserverDisplay();
  state.nextPassCache = {};
  state.lastTrackTime = 0;
}

function loadObserverLocation() {
  try {
    const s = JSON.parse(localStorage.getItem('sat_tracker_observer'));
    if (s && typeof s.lat === 'number') {
      state.observer.countryCode = s.countryCode || '';
      state.observer.placeName = s.placeName || '';
      state.observer.callsign = s.callsign || '';
      setObserverLocation(s.lat, s.lon, s.alt);
      updateCallsignBadge(s.callsign || '');
      state._hasExistingLocation = true;
      return;
    }
  } catch (e) {}
  state._hasExistingLocation = false;
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      p => setObserverLocation(p.coords.latitude, p.coords.longitude, p.coords.altitude || 0),
      () => setObserverLocation(39.7392, -104.9903, 0),
      { enableHighAccuracy: true, timeout: 8000 }
    );
  } else setObserverLocation(39.7392, -104.9903, 0);
}

function updateCallsignBadge(callsign) {
  const badge = document.getElementById('my-callsign-badge');
  const callEl = document.getElementById('header-callsign');
  if (callsign && callsign.length >= 2) {
    callEl.textContent = callsign;
    badge.classList.add('visible');
  } else {
    badge.classList.remove('visible');
  }
}

function updateObserverDisplay() {
  const { lat, lon, placeName } = state.observer;
  const grid = latLonToGrid(lat, lon);
  document.getElementById('observer-coords').textContent = `${Math.abs(lat).toFixed(4)}${lat >= 0 ? 'N' : 'S'} ${Math.abs(lon).toFixed(4)}${lon >= 0 ? 'E' : 'W'}`;
  document.getElementById('observer-grid').textContent = grid.toUpperCase();
  document.getElementById('observer-grid-map').textContent = grid.toUpperCase();
  const ituZ = getITUZone(lat, lon);
  const cqZ = getCQZone(lat, lon);
  const zonesEl = document.getElementById('observer-zones');
  if (zonesEl) zonesEl.textContent = `ITU ${ituZ} · CQ ${cqZ}`;
  // Update place labels
  const placeLabel = document.getElementById('observer-place-label');
  const qthHint = document.getElementById('qth-place-hint');
  const shortPlace = placeName ? placeName.split(',').slice(0, 2).join(',').trim() : '';
  if (placeLabel) placeLabel.textContent = shortPlace || `${Math.abs(lat).toFixed(2)}${lat >= 0 ? 'N' : 'S'}, ${Math.abs(lon).toFixed(2)}${lon >= 0 ? 'E' : 'W'} · Click to edit`;
  if (qthHint) qthHint.textContent = shortPlace || 'Click to set your station location';
}

// ============================================================
// SIDEBAR UI
// ============================================================
function buildSatelliteList() {
  const el = document.getElementById('sat-list');
  el.innerHTML = '';
  const cats = {};
  for (const c of SATELLITE_CATALOG) { if (!cats[c.category]) cats[c.category] = []; cats[c.category].push(c); }

  for (const [cn, sats] of Object.entries(cats)) {
    const cd = document.createElement('div'); cd.className = 'sat-category'; cd.textContent = cn; el.appendChild(cd);
    for (const s of sats) {
      if (!state.satellites[s.noradId]) continue;
      const item = document.createElement('div'); item.className = 'sat-item'; item.dataset.noradId = s.noradId;
      const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = state.visibleSatIds.has(s.noradId);
      cb.addEventListener('change', e => { e.stopPropagation(); toggleSatVis(s.noradId, cb.checked); });
      const dot = document.createElement('div'); dot.className = 'sat-dot'; dot.style.background = s.color;
      const nm = document.createElement('span'); nm.className = 'sat-name'; nm.textContent = s.name;
      const ev = document.createElement('span'); ev.className = 'sat-elev'; ev.dataset.elevFor = s.noradId; ev.textContent = '--';
      const rf = document.createElement('span'); rf.className = 'sat-rf-dot out-range'; rf.dataset.rfFor = s.noradId;
      item.append(cb, dot, nm, ev, rf);
      item.addEventListener('click', e => { if (e.target === cb) return; selectSat(s.noradId); if (!cb.checked) { cb.checked = true; toggleSatVis(s.noradId, true); } });
      el.appendChild(item);
    }
  }
}

function selectSat(nid) {
  const prevActive = state.activeSatId;
  state.activeSatId = nid;
  document.querySelectorAll('.sat-item').forEach(e => e.classList.toggle('active', parseInt(e.dataset.noradId) === nid));

  // Update entity styles
  if (prevActive != null && state.entities[prevActive]) updateSatEntityStyle(prevActive, false);
  if (state.entities[nid]) updateSatEntityStyle(nid, true);

  state.lastTrackTime = 0;
  delete state.nextPassCache[nid];

  // Camera flyTo satellite — position camera above the sub-satellite point
  // looking down at the globe with the satellite visible in context
  const sat = state.satellites[nid];
  if (sat && sat.position) {
    const pos = sat.position;
    const satAltM = pos.alt * 1000;
    // Camera goes to same lon/lat as satellite, but much higher altitude
    // This keeps the globe centered with the satellite dot visible on the globe
    const cameraAlt = satAltM + 12000000; // 12,000km above satellite
    state.viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(pos.lon, pos.lat, cameraAlt),
      orientation: {
        heading: 0,
        pitch: Cesium.Math.toRadians(-90), // look straight down at globe
        roll: 0,
      },
      duration: 1.5,
    });
  }

  updateDetailsPanel();
  RadioController.onSatelliteChange(nid);
}

function toggleSatVis(nid, vis) {
  if (vis) {
    state.visibleSatIds.add(nid);
    addSatMarker(nid);
    updateTracks(nid, new Date());
  } else {
    state.visibleSatIds.delete(nid);
    removeSatMarker(nid);
    if (state.activeSatId === nid) {
      updateFootprint(null);
      updateLosLine(null);
    }
  }
}

function getSatType(cat) {
  if (cat.name.startsWith('ISS')) return 'iss';
  if (cat.name.startsWith('NOAA')) return 'noaa';
  return 'cubesat'; // SO-50, AO-*, XW-3, TEVEL, FOX-1A
}

function buildSatSvg(type, col, rfVis, elev) {
  const sz = 90;
  const elevColor = elev >= 0 ? '#00e676' : '#4a5a6e';
  let svg = `<svg class="sat-craft-svg" width="${sz}" height="${sz}" viewBox="0 0 ${sz} ${sz}" xmlns="http://www.w3.org/2000/svg">`;

  // Background glow
  svg += `<defs>
    <radialGradient id="sglow"><stop offset="0%" stop-color="${col}" stop-opacity="0.12"/><stop offset="100%" stop-color="${col}" stop-opacity="0"/></radialGradient>
    <linearGradient id="spanel" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#1a3a6a"/><stop offset="100%" stop-color="#0d1f3d"/></linearGradient>
    <linearGradient id="spanelLit" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#2a5a9a"/><stop offset="100%" stop-color="#1a3a6a"/></linearGradient>
    <linearGradient id="sbody" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#2a3444"/><stop offset="100%" stop-color="#1a2232"/></linearGradient>
  </defs>`;
  svg += `<circle cx="${sz/2}" cy="${sz/2}" r="40" fill="url(#sglow)"/>`;

  if (type === 'iss') {
    // === ISS — truss + 8 solar arrays + modules ===
    const cx = 45, cy = 45;

    // Main truss (horizontal beam)
    svg += `<rect x="${cx-36}" y="${cy-1.5}" width="72" height="3" rx="1" fill="url(#sbody)" stroke="#3a4a5a" stroke-width="0.5"/>`;

    // Solar array pairs (4 pairs along the truss)
    const panelW = 13, panelH = 20;
    const positions = [-30, -14, 14, 30];
    positions.forEach((px, i) => {
      const grad = i < 2 ? 'spanel' : 'spanelLit';
      // Top panel
      svg += `<rect x="${cx+px-panelW/2}" y="${cy-panelH-3}" width="${panelW}" height="${panelH}" rx="0.5" fill="url(#${grad})" stroke="#2a4a6a" stroke-width="0.4"/>`;
      // Panel grid lines
      for (let g = 1; g < 4; g++) {
        svg += `<line x1="${cx+px-panelW/2}" y1="${cy-panelH-3+g*(panelH/4)}" x2="${cx+px+panelW/2}" y2="${cy-panelH-3+g*(panelH/4)}" stroke="#1a3050" stroke-width="0.3"/>`;
      }
      svg += `<line x1="${cx+px}" y1="${cy-panelH-3}" x2="${cx+px}" y2="${cy-3}" stroke="#1a3050" stroke-width="0.3"/>`;
      // Bottom panel
      svg += `<rect x="${cx+px-panelW/2}" y="${cy+3}" width="${panelW}" height="${panelH}" rx="0.5" fill="url(#${grad})" stroke="#2a4a6a" stroke-width="0.4"/>`;
      for (let g = 1; g < 4; g++) {
        svg += `<line x1="${cx+px-panelW/2}" y1="${cy+3+g*(panelH/4)}" x2="${cx+px+panelW/2}" y2="${cy+3+g*(panelH/4)}" stroke="#1a3050" stroke-width="0.3"/>`;
      }
      svg += `<line x1="${cx+px}" y1="${cy+3}" x2="${cx+px}" y2="${cy+3+panelH}" stroke="#1a3050" stroke-width="0.3"/>`;
      // Strut connecting panel to truss
      svg += `<line x1="${cx+px}" y1="${cy-3}" x2="${cx+px}" y2="${cy-1.5}" stroke="#3a4a5a" stroke-width="0.8"/>`;
      svg += `<line x1="${cx+px}" y1="${cy+1.5}" x2="${cx+px}" y2="${cy+3}" stroke="#3a4a5a" stroke-width="0.8"/>`;
    });

    // Pressurized modules (center cluster)
    svg += `<rect x="${cx-8}" y="${cy-4}" width="16" height="8" rx="2" fill="#1e2e3e" stroke="#3a5a7a" stroke-width="0.5"/>`;
    svg += `<rect x="${cx-3}" y="${cy-7}" width="6" height="14" rx="1.5" fill="#1a2a3a" stroke="#3a5a7a" stroke-width="0.4"/>`;
    // Docking ports
    svg += `<circle cx="${cx}" cy="${cy-7}" r="1" fill="#4a6a8a" stroke="#5a7a9a" stroke-width="0.3"/>`;
    svg += `<circle cx="${cx}" cy="${cy+7}" r="1" fill="#4a6a8a" stroke="#5a7a9a" stroke-width="0.3"/>`;
    // Window glow
    svg += `<rect x="${cx-5}" y="${cy-1.5}" width="2" height="2" rx="0.5" fill="#4da6ff" opacity="0.6"/>`;
    svg += `<rect x="${cx+3}" y="${cy-1.5}" width="2" height="2" rx="0.5" fill="#4da6ff" opacity="0.4"/>`;

    // RF signal indicator if visible
    if (rfVis) {
      svg += `<circle cx="${cx}" cy="${cy}" r="22" fill="none" stroke="${col}" stroke-opacity="0.12" stroke-width="0.5"/>`;
      svg += `<circle cx="${cx}" cy="${cy}" r="28" fill="none" stroke="${col}" stroke-opacity="0.06" stroke-width="0.5"/>`;
    }

  } else if (type === 'noaa') {
    // === NOAA POES — bus + single large solar paddle ===
    const cx = 45, cy = 42;

    // Main bus (rectangular body)
    svg += `<rect x="${cx-7}" y="${cy-10}" width="14" height="22" rx="1.5" fill="url(#sbody)" stroke="#3a5a7a" stroke-width="0.5"/>`;

    // Solar array (single long paddle to one side)
    svg += `<rect x="${cx+9}" y="${cy-18}" width="22" height="36" rx="0.5" fill="url(#spanel)" stroke="#2a4a6a" stroke-width="0.4"/>`;
    // Panel grid
    for (let g = 1; g < 6; g++) {
      svg += `<line x1="${cx+9}" y1="${cy-18+g*6}" x2="${cx+31}" y2="${cy-18+g*6}" stroke="#1a3050" stroke-width="0.3"/>`;
    }
    svg += `<line x1="${cx+20}" y1="${cy-18}" x2="${cx+20}" y2="${cy+18}" stroke="#1a3050" stroke-width="0.3"/>`;
    // Strut
    svg += `<rect x="${cx+7}" y="${cy-1}" width="3" height="2" fill="#3a4a5a"/>`;

    // AVHRR scanner (top dome)
    svg += `<circle cx="${cx}" cy="${cy-12}" r="4" fill="#1a2a3a" stroke="#4a6a8a" stroke-width="0.4"/>`;
    svg += `<circle cx="${cx}" cy="${cy-12}" r="2" fill="#2a3a4a" stroke="#5a7a9a" stroke-width="0.3"/>`;

    // Antenna boom (bottom)
    svg += `<line x1="${cx}" y1="${cy+12}" x2="${cx}" y2="${cy+22}" stroke="#4a5a6a" stroke-width="0.8"/>`;
    svg += `<line x1="${cx-4}" y1="${cy+22}" x2="${cx+4}" y2="${cy+22}" stroke="#4a5a6a" stroke-width="0.6"/>`;
    svg += `<circle cx="${cx}" cy="${cy+22}" r="1.2" fill="#3a5a7a"/>`;

    // Side antennas
    svg += `<line x1="${cx-7}" y1="${cy+4}" x2="${cx-16}" y2="${cy+14}" stroke="#4a5a6a" stroke-width="0.6"/>`;
    svg += `<circle cx="${cx-16}" cy="${cy+14}" r="0.8" fill="#5a7a9a"/>`;

    // Details on bus
    svg += `<rect x="${cx-5}" y="${cy-6}" width="3" height="3" rx="0.5" fill="#1a3050" stroke="#2a4a6a" stroke-width="0.3"/>`;
    svg += `<rect x="${cx+2}" y="${cy-6}" width="3" height="3" rx="0.5" fill="#1a3050" stroke="#2a4a6a" stroke-width="0.3"/>`;
    svg += `<rect x="${cx-4}" y="${cy}" width="8" height="4" rx="0.5" fill="#14222f" stroke="#2a3a4a" stroke-width="0.3"/>`;

    if (rfVis) {
      svg += `<circle cx="${cx}" cy="${cy}" r="20" fill="none" stroke="${col}" stroke-opacity="0.12" stroke-width="0.5"/>`;
      svg += `<circle cx="${cx}" cy="${cy}" r="26" fill="none" stroke="${col}" stroke-opacity="0.06" stroke-width="0.5"/>`;
    }

  } else {
    // === CubeSat — 1U/3U with deployable solar panels ===
    const cx = 45, cy = 45;

    // Main body (slightly elongated for 3U)
    svg += `<rect x="${cx-6}" y="${cy-9}" width="12" height="18" rx="1" fill="url(#sbody)" stroke="#3a5a7a" stroke-width="0.5"/>`;

    // Deployable solar panels (folded out like butterfly wings)
    // Left panel
    svg += `<rect x="${cx-26}" y="${cy-8}" width="18" height="16" rx="0.5" fill="url(#spanel)" stroke="#2a4a6a" stroke-width="0.4"/>`;
    for (let g = 1; g < 4; g++) {
      svg += `<line x1="${cx-26}" y1="${cy-8+g*4}" x2="${cx-8}" y2="${cy-8+g*4}" stroke="#1a3050" stroke-width="0.3"/>`;
    }
    svg += `<line x1="${cx-17}" y1="${cy-8}" x2="${cx-17}" y2="${cy+8}" stroke="#1a3050" stroke-width="0.3"/>`;
    // Left hinge
    svg += `<rect x="${cx-8}" y="${cy-1}" width="2" height="2" fill="#4a5a6a"/>`;

    // Right panel
    svg += `<rect x="${cx+8}" y="${cy-8}" width="18" height="16" rx="0.5" fill="url(#spanelLit)" stroke="#2a4a6a" stroke-width="0.4"/>`;
    for (let g = 1; g < 4; g++) {
      svg += `<line x1="${cx+8}" y1="${cy-8+g*4}" x2="${cx+26}" y2="${cy-8+g*4}" stroke="#1a3050" stroke-width="0.3"/>`;
    }
    svg += `<line x1="${cx+17}" y1="${cy-8}" x2="${cx+17}" y2="${cy+8}" stroke="#1a3050" stroke-width="0.3"/>`;
    // Right hinge
    svg += `<rect x="${cx+6}" y="${cy-1}" width="2" height="2" fill="#4a5a6a"/>`;

    // Body details
    svg += `<rect x="${cx-4}" y="${cy-6}" width="8" height="5" rx="0.5" fill="#14222f" stroke="#2a3a4a" stroke-width="0.3"/>`;
    // Antenna (top)
    svg += `<line x1="${cx}" y1="${cy-9}" x2="${cx}" y2="${cy-16}" stroke="#5a7a9a" stroke-width="0.6"/>`;
    svg += `<line x1="${cx-3}" y1="${cy-15}" x2="${cx+3}" y2="${cy-15}" stroke="#5a7a9a" stroke-width="0.5"/>`;
    // UHF antenna (bottom whip)
    svg += `<line x1="${cx+3}" y1="${cy+9}" x2="${cx+6}" y2="${cy+18}" stroke="#5a7a9a" stroke-width="0.5"/>`;
    svg += `<line x1="${cx-3}" y1="${cy+9}" x2="${cx-6}" y2="${cy+18}" stroke="#5a7a9a" stroke-width="0.5"/>`;

    // Status LED
    svg += `<circle cx="${cx}" cy="${cy+3}" r="1" fill="${col}" opacity="0.8"/>`;

    if (rfVis) {
      svg += `<circle cx="${cx}" cy="${cy}" r="20" fill="none" stroke="${col}" stroke-opacity="0.12" stroke-width="0.5"/>`;
      svg += `<circle cx="${cx}" cy="${cy}" r="26" fill="none" stroke="${col}" stroke-opacity="0.06" stroke-width="0.5"/>`;
    }
  }

  // Satellite color accent line at bottom
  svg += `<rect x="15" y="${sz-4}" width="${sz-30}" height="1.5" rx="0.75" fill="${col}" opacity="0.5"/>`;

  svg += '</svg>';
  return svg;
}

function buildSatGraphic(cat, pos, look, sat) {
  const type = getSatType(cat);
  const elev = look ? look.elevation : -90;
  const rfVis = sat.rfVisible;
  const craftSvg = buildSatSvg(type, cat.color, rfVis, elev);

  // Info beside the graphic
  const altStr = pos ? `${pos.alt.toFixed(0)} km` : '--';
  const rangeStr = look ? `${look.range.toFixed(0)} km` : '--';
  const velStr = pos ? `${Math.sqrt(pos.vel.x ** 2 + pos.vel.y ** 2 + pos.vel.z ** 2).toFixed(1)} km/s` : '--';
  const elevStr = look ? `${look.elevation.toFixed(1)}°` : '--';
  const elevCls = look && look.elevation >= 0 ? 'above-hz' : 'below-hz';

  return `<div class="sat-graphic">${craftSvg}<div class="sat-graphic-info">
    <div class="sg-row"><span class="sg-label">Altitude</span><span class="sg-value">${altStr}</span></div>
    <div class="sg-row"><span class="sg-label">Range</span><span class="sg-value">${rangeStr}</span></div>
    <div class="sg-row"><span class="sg-label">Velocity</span><span class="sg-value">${velStr}</span></div>
    <div class="sg-row"><span class="sg-label">Elevation</span><span class="sg-value ${elevCls}">${elevStr}</span></div>
  </div></div>`;
}

function updateDetailsPanel() {
  const panel = document.getElementById('details-panel');
  if (state.activeSatId == null || !state.satellites[state.activeSatId]) {
    panel.innerHTML = '<div class="no-selection">SELECT A BIRD TO VIEW TELEMETRY</div>'; return;
  }
  const sat = state.satellites[state.activeSatId], cat = sat.catalogEntry, pos = sat.position, look = sat.lookAngles;
  let h = '';

  h += `<div class="detail-header"><span class="detail-name-dot" style="background:${cat.color}"></span><span class="detail-sat-name">${cat.name}</span><span class="detail-norad">#${cat.noradId}</span></div>`;

  // Satellite orbit graphic
  h += buildSatGraphic(cat, pos, look, sat);

  h += '<div class="detail-grid">';
  const r = (l, v) => `<div class="detail-row"><span class="detail-label">${l}</span><span class="detail-value">${v}</span></div>`;
  if (pos) {
    h += r('Altitude', `${pos.alt.toFixed(1)} km`);
    h += r('Latitude', `${pos.lat.toFixed(4)}°`);
    h += r('Longitude', `${pos.lon.toFixed(4)}°`);
    h += r('Period', `${getOrbitalPeriod(sat.satrec).toFixed(1)} min`);
    h += r('Grid Sq', latLonToGrid(pos.lat, pos.lon).toUpperCase());
    h += r('Velocity', `${Math.sqrt(pos.vel.x ** 2 + pos.vel.y ** 2 + pos.vel.z ** 2).toFixed(2)} km/s`);
  }
  if (look) {
    h += r('Azimuth', `${look.azimuth.toFixed(1)}°`);
    h += r('Elevation', `${look.elevation.toFixed(1)}°`);
    h += r('Range', `${look.range.toFixed(0)} km`);
    h += r('Range Rate', `${(sat.rangeRate || 0).toFixed(3)} km/s`);
  }
  if (sat.tleAgeHours != null) {
    const ageStr = sat.tleAgeHours < 24 ? `${sat.tleAgeHours.toFixed(0)}h` : `${(sat.tleAgeHours / 24).toFixed(1)}d`;
    const ageColor = sat.tleAgeHours < 48 ? 'var(--green)' : sat.tleAgeHours < 168 ? 'var(--yellow)' : 'var(--red)';
    h += `<div class="detail-row"><span class="detail-label">TLE Age</span><span class="detail-value" style="color:${ageColor}">${ageStr}</span></div>`;
  }
  h += r('Mode', cat.mode);
  h += '</div>';

  h += '<div class="vis-row">';
  h += sat.rfVisible
    ? '<div class="vis-badge rf-yes"><span class="vis-dot"></span>RF In Range</div>'
    : '<div class="vis-badge rf-no"><span class="vis-dot"></span>RF Below Horizon</div>';
  h += sat.visVisible
    ? '<div class="vis-badge vis-yes"><span class="vis-dot"></span>Optically Visible</div>'
    : '<div class="vis-badge vis-no"><span class="vis-dot"></span>Not Visible</div>';
  h += '</div>';

  h += '<div class="freq-section">';
  h += '<div class="freq-section-label">Doppler-Corrected Frequencies</div>';
  const rr = sat.rangeRate || 0;
  if (cat.downlink) {
    const dShift = computeDoppler(cat.downlink, rr);
    const corrected = cat.downlink + dShift;
    const sign = dShift >= 0 ? '+' : '';
    const cls = dShift >= 0 ? 'positive' : 'negative';
    h += `<div class="freq-row"><span class="freq-label">Downlink</span><span class="freq-value">${corrected.toFixed(4)} MHz</span><span class="freq-doppler ${cls}">${sign}${(dShift * 1000).toFixed(1)} Hz</span></div>`;
  }
  if (cat.uplink) {
    const uShift = computeDoppler(cat.uplink, rr);
    const corrected = cat.uplink - uShift;
    const sign = -uShift >= 0 ? '+' : '';
    const cls = -uShift >= 0 ? 'positive' : 'negative';
    h += `<div class="freq-row"><span class="freq-label">Uplink</span><span class="freq-value">${corrected.toFixed(4)} MHz</span><span class="freq-doppler ${cls}">${sign}${(-uShift * 1000).toFixed(1)} Hz</span></div>`;
  }

  // Doppler shift gauge
  const shiftHz = cat.downlink ? computeDoppler(cat.downlink, rr) * 1000 : 0;
  const maxShift = 10000; // ±10 kHz scale
  const pct = Math.max(-1, Math.min(1, shiftHz / maxShift));
  const approaching = rr < -0.1;
  const receding = rr > 0.1;
  const rrAbs = Math.abs(rr).toFixed(2);
  h += '<div class="doppler-gauge-wrap">';
  h += '<div class="doppler-gauge-labels"><span>+' + (maxShift/1000).toFixed(0) + ' kHz</span><span>0</span><span>-' + (maxShift/1000).toFixed(0) + ' kHz</span></div>';
  h += '<div class="doppler-gauge">';
  h += '<div class="doppler-gauge-center"></div>';
  h += `<div class="doppler-gauge-fill" style="left:${50 + pct * 50}%;"></div>`;
  h += '</div>';
  h += `<div class="doppler-direction ${approaching ? 'approaching' : receding ? 'receding' : 'stationary'}">`;
  if (approaching) h += `<span class="dir-arrow">\u25C0\u25C0</span> Approaching <span class="dir-rate">${rrAbs} km/s</span>`;
  else if (receding) h += `<span class="dir-rate">${rrAbs} km/s</span> Receding <span class="dir-arrow">\u25B6\u25B6</span>`;
  else h += `<span class="dir-rate">~0 km/s</span> At closest approach`;
  h += '</div></div>';

  // Doppler S-curve for next pass
  const dopplerPasses = state.nextPassCache[state.activeSatId];
  const nextPass = Array.isArray(dopplerPasses) && dopplerPasses.length > 0 ? dopplerPasses[0] : dopplerPasses;
  if (nextPass && cat.downlink && sat.satrec && state.observerGd) {
    const curve = computeDopplerCurve(sat.satrec, state.observerGd, nextPass, cat.downlink, 50);
    if (curve.length > 1) {
      const w = 180, ht = 80, pad = 2;
      const shiftVals = curve.map(p => p.shiftHz);
      const yMax = Math.max(Math.abs(Math.min(...shiftVals)), Math.abs(Math.max(...shiftVals)), 500);
      const xScale = (w - pad * 2) / (curve.length - 1);
      const yScale = (ht - pad * 2) / (yMax * 2);
      const yMid = ht / 2;
      // Build path
      let pathD = '';
      let areaD = '';
      curve.forEach((p, i) => {
        const x = pad + i * xScale;
        const y = yMid - p.shiftHz * yScale;
        pathD += (i === 0 ? 'M' : 'L') + x.toFixed(1) + ',' + y.toFixed(1);
        areaD += (i === 0 ? 'M' : 'L') + x.toFixed(1) + ',' + y.toFixed(1);
      });
      // Close area
      areaD += `L${(pad + (curve.length - 1) * xScale).toFixed(1)},${yMid}L${pad},${yMid}Z`;

      // Find "now" position on curve
      const now = Date.now();
      let nowX = -1, nowY = -1;
      const tStart = curve[0].time, tEnd = curve[curve.length - 1].time;
      if (now >= tStart && now <= tEnd) {
        const frac = (now - tStart) / (tEnd - tStart);
        const idx = frac * (curve.length - 1);
        const i0 = Math.floor(idx), i1 = Math.min(i0 + 1, curve.length - 1);
        const t = idx - i0;
        nowX = pad + idx * xScale;
        nowY = yMid - (curve[i0].shiftHz * (1 - t) + curve[i1].shiftHz * t) * yScale;
      }

      // Pass active zone background
      const passStartI = curve.findIndex(p => p.inPass);
      const passEndI = curve.length - 1 - [...curve].reverse().findIndex(p => p.inPass);
      const passX1 = passStartI >= 0 ? pad + passStartI * xScale : 0;
      const passX2 = passEndI >= 0 ? pad + passEndI * xScale : w;

      const passLabel = now >= nextPass.start.getTime() && now <= nextPass.end.getTime()
        ? 'LIVE — Doppler Curve' : 'Next Pass — Doppler Curve';

      h += `<div class="doppler-chart-wrap">`;
      h += `<div class="doppler-chart-label">${passLabel}</div>`;
      h += `<svg class="doppler-chart" viewBox="0 0 ${w} ${ht}" preserveAspectRatio="none">`;
      // Pass zone
      h += `<rect x="${passX1.toFixed(1)}" y="0" width="${(passX2 - passX1).toFixed(1)}" height="${ht}" fill="rgba(0,230,118,0.06)" rx="2"/>`;
      // Zero line
      h += `<line x1="${pad}" y1="${yMid}" x2="${w - pad}" y2="${yMid}" stroke="rgba(255,255,255,0.08)" stroke-width="0.5" stroke-dasharray="2,2"/>`;
      // Gradient area fill
      h += `<defs><linearGradient id="dg" x1="0" y1="0" x2="0" y2="1">`;
      h += `<stop offset="0%" stop-color="var(--orange)" stop-opacity="0.25"/>`;
      h += `<stop offset="50%" stop-color="var(--accent)" stop-opacity="0.02"/>`;
      h += `<stop offset="100%" stop-color="var(--accent)" stop-opacity="0.25"/>`;
      h += `</linearGradient></defs>`;
      h += `<path d="${areaD}" fill="url(#dg)"/>`;
      // S-curve line
      h += `<path d="${pathD}" fill="none" stroke="url(#dl)" stroke-width="1.5" stroke-linecap="round"/>`;
      h += `<defs><linearGradient id="dl" x1="0" y1="0" x2="0" y2="1">`;
      h += `<stop offset="0%" stop-color="var(--orange)"/>`;
      h += `<stop offset="50%" stop-color="#ffffff"/>`;
      h += `<stop offset="100%" stop-color="var(--accent)"/>`;
      h += `</linearGradient></defs>`;
      // Now marker
      if (nowX >= 0) {
        h += `<line x1="${nowX.toFixed(1)}" y1="0" x2="${nowX.toFixed(1)}" y2="${ht}" stroke="var(--green)" stroke-width="0.8" stroke-dasharray="2,1"/>`;
        h += `<circle cx="${nowX.toFixed(1)}" cy="${nowY.toFixed(1)}" r="3" fill="var(--green)" stroke="#000" stroke-width="0.5"/>`;
      }
      // Labels
      h += `<text x="${w - pad}" y="${pad + 7}" text-anchor="end" fill="var(--orange)" font-size="7" font-family="monospace" opacity="0.7">+${(yMax/1000).toFixed(1)}k</text>`;
      h += `<text x="${w - pad}" y="${ht - pad}" text-anchor="end" fill="var(--accent)" font-size="7" font-family="monospace" opacity="0.7">-${(yMax/1000).toFixed(1)}k</text>`;
      h += `</svg>`;
      h += `<div class="doppler-chart-times"><span>${nextPass.start.toUTCString().slice(17,22)} UTC</span><span>${nextPass.end.toUTCString().slice(17,22)} UTC</span></div>`;
      h += '</div>';
    }
  }
  h += '</div>';

  // Radio tuning badge
  if (state.radio.connected && state.radio.config.dopplerCorrection) {
    h += '<div class="radio-tuned-badge"><span class="radio-dot"></span>';
    h += 'RADIO TUNED \u2014 ' + (state.radio.config.splitVfo ? 'Split VFO (Full Duplex)' : 'Simplex (RX Only)');
    h += '</div>';
  }

  const sl = sat.signalLevel || 0;
  h += '<div class="signal-meter"><div class="signal-meter-label">Estimated Signal Strength</div><div class="signal-bar-container">';
  for (let i = 1; i <= 9; i++) {
    h += `<div class="signal-bar s${i} ${i <= sl ? 'active' : ''}"></div>`;
  }
  h += `<span class="signal-value">S${sl}</span></div></div>`;

  if (look) {
    const needleAngle = look.azimuth;
    h += `<div class="compass-section">
      <div class="compass-container"><div class="compass-ring">
        <span class="compass-cardinal compass-n">N</span><span class="compass-cardinal compass-s">S</span>
        <span class="compass-cardinal compass-e">E</span><span class="compass-cardinal compass-w">W</span>
        <div class="compass-needle" style="transform:translate(-50%,-100%) rotate(${needleAngle}deg);"></div>
        <div class="compass-center"></div>
      </div></div>
      <div class="compass-data">
        <div class="cd-row"><span class="cd-label">Azimuth</span><span class="cd-value">${look.azimuth.toFixed(1)}°</span></div>
        <div class="cd-row"><span class="cd-label">Elevation</span><span class="cd-value" style="color:${look.elevation >= 0 ? 'var(--green)' : 'var(--red)'}">${look.elevation.toFixed(1)}°</span></div>
        <div class="cd-row"><span class="cd-label">Bearing</span><span class="cd-value">${azToBearing(look.azimuth)}</span></div>
        <div class="cd-row"><span class="cd-label">Slant Range</span><span class="cd-value">${look.range.toFixed(0)} km</span></div>
      </div></div>`;
  }

  const passData = state.nextPassCache[state.activeSatId];
  const passes = Array.isArray(passData) ? passData : (passData ? [passData] : []);
  h += '<div class="pass-section"><div class="pass-title">Pass Schedule <span class="pass-count">' + (passes.length > 0 ? passes.length + ' passes next 24h' : '') + '</span></div>';

  if (passes.length > 0) {
    // Next pass summary chips
    const pass = passes[0];
    const tu = pass.start - new Date();
    let ts;
    if (tu <= 0) ts = '<span style="color:var(--green)">NOW!</span>';
    else { const hr = Math.floor(tu / 3600000), mn = Math.floor((tu % 3600000) / 60000); ts = hr > 0 ? `${hr}h ${mn}m` : `${mn}m`; }
    const quality = pass.maxEl >= 60 ? 'excellent' : pass.maxEl >= 30 ? 'good' : pass.maxEl >= 15 ? 'fair' : 'poor';
    const qLabel = pass.maxEl >= 60 ? 'S9+' : pass.maxEl >= 30 ? 'FB' : pass.maxEl >= 15 ? 'OK' : 'QRP';
    h += '<div class="pass-info">';
    h += `<div class="pass-chip"><span class="pc-label">Next In </span><span class="pc-value ${tu <= 300000 ? 'urgent' : ''}">${ts}</span></div>`;
    h += `<div class="pass-chip"><span class="pc-label">Max El </span><span class="pc-value">${pass.maxEl.toFixed(0)}°</span><span class="pass-quality ${quality}">${qLabel}</span></div>`;
    h += `<div class="pass-chip"><span class="pc-label">Duration </span><span class="pc-value">${Math.round(pass.duration / 60)}m${Math.round(pass.duration % 60).toString().padStart(2,'0')}s</span></div>`;
    h += '</div>';

    // Full pass schedule table
    h += '<div class="pass-table-wrap"><table class="pass-table"><thead><tr>';
    h += '<th>#</th><th>AOS</th><th>AOS Az</th><th>Max El</th><th>LOS</th><th>LOS Az</th><th>Dur</th>';
    h += '</tr></thead><tbody>';

    const now = new Date();
    passes.forEach((p, i) => {
      const isActive = p.start <= now && p.end >= now;
      const isPast = p.end < now;
      const pq = p.maxEl >= 60 ? 'excellent' : p.maxEl >= 30 ? 'good' : p.maxEl >= 15 ? 'fair' : 'poor';
      const pqL = p.maxEl >= 60 ? 'S9+' : p.maxEl >= 30 ? 'FB' : p.maxEl >= 15 ? 'OK' : 'QRP';
      const aosAzDir = typeof p.aosAz === 'number' ? azToBearing(p.aosAz * 180 / Math.PI) : '--';
      const losAzDir = typeof p.losAz === 'number' ? azToBearing(p.losAz * 180 / Math.PI) : '--';
      const maxElAzDir = azToBearing(p.maxElAz * 180 / Math.PI);
      const durM = Math.floor(p.duration / 60);
      const durS = Math.round(p.duration % 60);
      const rowClass = isActive ? 'pass-row active' : isPast ? 'pass-row past' : 'pass-row';
      h += `<tr class="${rowClass}">`;
      h += `<td class="pass-num">${i + 1}</td>`;
      h += `<td class="pass-time">${p.start.toUTCString().slice(0, 16)}<br><span class="pass-hms">${p.start.toUTCString().slice(17, 25)}</span></td>`;
      h += `<td class="pass-az">${aosAzDir}</td>`;
      h += `<td class="pass-el"><span class="pass-quality ${pq}">${p.maxEl.toFixed(0)}° ${pqL}</span><br><span class="pass-dir">${maxElAzDir}</span></td>`;
      h += `<td class="pass-time"><span class="pass-hms">${p.end.toUTCString().slice(17, 25)}</span></td>`;
      h += `<td class="pass-az">${losAzDir}</td>`;
      h += `<td class="pass-dur">${durM}m${durS.toString().padStart(2, '0')}s</td>`;
      h += '</tr>';
    });
    h += '</tbody></table></div>';
  } else {
    h += '<div class="pass-info"><div class="pass-chip"><span class="pc-label">Computing...</span></div></div>';
  }
  h += '</div>';

  panel.innerHTML = h;
}

function azToBearing(az) {
  const dirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
  return dirs[Math.round(az / 22.5) % 16];
}

function updateElevBadges() {
  if (!state.observerGd) return;
  const now = new Date();
  for (const [nidStr, sat] of Object.entries(state.satellites)) {
    const nid = parseInt(nidStr);
    const el = document.querySelector(`[data-elev-for="${nid}"]`);
    const rf = document.querySelector(`[data-rf-for="${nid}"]`);
    if (!el) continue;
    const la = getLookAngles(sat.satrec, state.observerGd, now);
    if (la) {
      el.textContent = `${la.elevation.toFixed(0)}°`;
      el.classList.toggle('above', la.elevation >= state.settings.minElevation);
      if (rf) { rf.classList.toggle('in-range', la.elevation >= state.settings.minElevation); rf.classList.toggle('out-range', la.elevation < state.settings.minElevation); }
    }
  }
}

// ============================================================
// ANIMATION LOOP
// ============================================================
function animLoop() {
  const now = Date.now();
  if (now - state.lastCalcTime >= state.settings.updateInterval) {
    state.lastCalcTime = now;
    const date = new Date();
    document.getElementById('clock').textContent = date.toUTCString().slice(0, -4).replace(/ GMT$/, '') + ' UTC';

    // Sync Cesium clock
    if (state.viewer) {
      state.viewer.clock.currentTime = Cesium.JulianDate.fromDate(date);
    }

    // Update terminator overlay every 60s (it moves slowly)
    if (now - (state.lastTerminatorTime || 0) >= 60000) {
      state.lastTerminatorTime = now;
      updateTerminator(date);
    }

    for (const nid of state.visibleSatIds) {
      const sat = state.satellites[nid]; if (!sat) continue;
      const pos = getSatPosition(sat.satrec, date); if (!pos) continue;
      sat.position = pos;

      // Update entity position at true 3D orbital altitude
      const ents = state.entities[nid];
      if (ents) {
        ents.point.position = Cesium.Cartesian3.fromDegrees(pos.lon, pos.lat, pos.alt * 1000);
      }

      if (state.observerGd) {
        sat.lookAngles = getLookAngles(sat.satrec, state.observerGd, date);
        sat.rfVisible = sat.lookAngles && sat.lookAngles.elevation >= state.settings.minElevation;
        sat.visVisible = computeVisualVis(sat, state.observerGd, state.observer.lat, state.observer.lon, date);
        sat.rangeRate = getRangeRate(sat.satrec, state.observerGd, date);
        sat.signalLevel = sat.lookAngles ? estimateSignalLevel(sat.lookAngles.elevation, sat.lookAngles.range, pos.alt) : 0;
      }
    }

    if (state.activeSatId != null && state.satellites[state.activeSatId]) {
      const activePos = state.satellites[state.activeSatId].position;
      updateFootprint(activePos);
      updateDopplerRings(activePos);
      updateLosLine(activePos);

      // Camera track mode — follow satellite, looking down at globe
      if (state.trackingMode && activePos) {
        state.viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(activePos.lon, activePos.lat, activePos.alt * 1000 + 10000000),
          orientation: {
            heading: 0,
            pitch: Cesium.Math.toRadians(-90),
            roll: 0,
          },
          duration: 0.5,
        });
      }
    }

    updateDetailsPanel();
    RadioController.updateDoppler();
    updateRadioFreqDisplay();
    updateElevBadges();

    let above = 0;
    for (const s of Object.values(state.satellites)) if (s.rfVisible) above++;
    const statsEl = document.getElementById('tracking-stats');
    statsEl.innerHTML = `<span><span class="stat-label">TRK:</span> <span class="stat-value">${state.visibleSatIds.size}</span></span><span><span class="stat-label">AOS:</span> <span class="stat-value ${above > 0 ? 'highlight' : ''}">${above}</span></span>`;
  }

  // Update ground tracks every 15 seconds
  if (now - state.lastTrackTime >= 15000) {
    state.lastTrackTime = now;
    const date = new Date();
    for (const nid of state.visibleSatIds) updateTracks(nid, date);
  }

  state.animFrameId = requestAnimationFrame(animLoop);
}

// Next pass background computation — multi-pass schedule
function bgComputePasses() {
  if (!state.observerGd || state.activeSatId == null) return;
  const sat = state.satellites[state.activeSatId]; if (!sat) return;
  const cached = state.nextPassCache[state.activeSatId];
  // Recompute if no cache, or if first pass is now in the past
  if (!cached || (Array.isArray(cached) && cached.length > 0 && cached[0].end < new Date())) {
    const passes = findNextNPasses(sat.satrec, state.observerGd, state.settings.minElevation, new Date(), 10, 24);
    state.nextPassCache[state.activeSatId] = passes;
  }
}
setInterval(bgComputePasses, 3000);

// ============================================================
// EVENT HANDLERS
// ============================================================
function setupEvents() {
  document.getElementById('btn-gps').addEventListener('click', () => {
    if (!navigator.geolocation) return alert('No GPS');
    navigator.geolocation.getCurrentPosition(
      p => setObserverLocation(p.coords.latitude, p.coords.longitude, p.coords.altitude || 0),
      e => alert('GPS failed: ' + e.message), { enableHighAccuracy: true, timeout: 10000 });
  });

  // Open Station Profile — accessible from multiple entry points
  function openStationProfile() {
    document.getElementById('input-lat').value = state.observer.lat;
    document.getElementById('input-lon').value = state.observer.lon;
    document.getElementById('input-alt').value = state.observer.alt || 0;
    document.getElementById('input-location-search').value = state.observer.placeName || '';
    document.getElementById('input-callsign').value = state.observer.callsign || '';
    updateDerivedDisplay(state.observer.lat, state.observer.lon, state.observer.countryCode);
    // Show detected country from callsign if present
    const cs = state.observer.callsign;
    if (cs) {
      const det = detectCallsignCountry(cs);
      const detEl = document.getElementById('callsign-detected');
      detEl.innerHTML = det ? `<span class="cd-match">${det.name}</span> — ${det.dxcc}` : '';
    }
    document.getElementById('location-modal').classList.remove('hidden');
  }

  // QTH card in bottom bar → opens Station Profile
  document.getElementById('qth-card').addEventListener('click', openStationProfile);
  // Grid overlay on map → opens Station Profile
  document.getElementById('grid-overlay').addEventListener('click', openStationProfile);
  // Callsign badge in header → opens Station Profile
  document.getElementById('my-callsign-badge').addEventListener('click', openStationProfile);

  // Callsign input — detect country from prefix as user types
  document.getElementById('input-callsign').addEventListener('input', () => {
    const cs = document.getElementById('input-callsign').value.trim();
    const detEl = document.getElementById('callsign-detected');
    if (cs.length < 2) { detEl.innerHTML = ''; return; }
    const det = detectCallsignCountry(cs);
    if (det) {
      detEl.innerHTML = `Detected: <span class="cd-match">${det.name}</span> — ${det.dxcc}`;
    } else {
      detEl.innerHTML = '';
    }
  });

  // Geocoding search input
  const searchInput = document.getElementById('input-location-search');
  const resultsDiv = document.getElementById('location-results');

  searchInput.addEventListener('input', () => {
    clearTimeout(geocodeTimeout);
    const q = searchInput.value.trim();
    if (q.length < 2) { resultsDiv.style.display = 'none'; return; }
    geocodeTimeout = setTimeout(async () => {
      const results = await geocodeSearch(q);
      if (results.length === 0) { resultsDiv.style.display = 'none'; return; }
      resultsDiv.innerHTML = '';
      results.forEach(r => {
        const div = document.createElement('div');
        div.className = 'loc-result';
        const name = r.display_name.split(',').slice(0, 2).join(',');
        const detail = r.display_name.split(',').slice(2, 4).join(',').trim();
        div.innerHTML = `<div class="loc-name">${name}</div><div class="loc-detail">${detail}</div>`;
        div.addEventListener('click', () => {
          const lat = parseFloat(r.lat);
          const lon = parseFloat(r.lon);
          const cc = r.address?.country_code?.toUpperCase() || '';
          document.getElementById('input-lat').value = lat.toFixed(4);
          document.getElementById('input-lon').value = lon.toFixed(4);
          searchInput.value = r.display_name.split(',').slice(0, 3).join(',').trim();
          state._pendingCountryCode = cc;
          state._pendingPlaceName = searchInput.value;
          updateDerivedDisplay(lat, lon, cc);
          resultsDiv.style.display = 'none';
        });
        resultsDiv.appendChild(div);
      });
      resultsDiv.style.display = 'block';
    }, 400);
  });

  // Close results when clicking outside
  document.addEventListener('click', e => {
    if (!e.target.closest('.location-search-wrap')) resultsDiv.style.display = 'none';
  });

  // Update derived data when coordinates change manually
  ['input-lat', 'input-lon'].forEach(id => {
    document.getElementById(id).addEventListener('input', () => {
      const lat = parseFloat(document.getElementById('input-lat').value);
      const lon = parseFloat(document.getElementById('input-lon').value);
      if (!isNaN(lat) && !isNaN(lon) && lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
        updateDerivedDisplay(lat, lon, state._pendingCountryCode || state.observer.countryCode);
      }
    });
  });

  document.getElementById('btn-loc-cancel').addEventListener('click', () => {
    document.getElementById('location-modal').classList.add('hidden');
    state._pendingCountryCode = null;
    state._pendingPlaceName = null;
  });
  document.getElementById('btn-loc-save').addEventListener('click', () => {
    const lat = parseFloat(document.getElementById('input-lat').value);
    const lon = parseFloat(document.getElementById('input-lon').value);
    const alt = parseFloat(document.getElementById('input-alt').value) || 0;
    if (isNaN(lat) || isNaN(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) return alert('Invalid coordinates');
    state.observer.countryCode = state._pendingCountryCode || state.observer.countryCode || '';
    state.observer.placeName = state._pendingPlaceName || state.observer.placeName || '';
    // Save callsign
    const callsign = document.getElementById('input-callsign').value.trim().toUpperCase();
    state.observer.callsign = callsign;
    updateCallsignBadge(callsign);
    setObserverLocation(lat, lon, alt);
    document.getElementById('location-modal').classList.add('hidden');
    state._pendingCountryCode = null;
    state._pendingPlaceName = null;
  });

  document.getElementById('btn-settings').addEventListener('click', () => {
    document.getElementById('setting-min-elev').value = state.settings.minElevation;
    document.getElementById('setting-interval').value = state.settings.updateInterval;
    document.getElementById('setting-basemap').value = state.settings.baseMap || 'dark';
    // Populate radio settings
    document.getElementById('setting-radio-brand').value = state.radio.config.brand || 'none';
    document.getElementById('setting-radio-brand').dispatchEvent(new Event('change'));
    document.getElementById('setting-radio-doppler').checked = state.radio.config.dopplerCorrection !== false;
    document.getElementById('setting-radio-autotune').checked = state.radio.config.autoTune !== false;
    document.getElementById('setting-radio-split').checked = !!state.radio.config.splitVfo;
    if (state.radio.config.brand === 'rigctld') document.getElementById('setting-rigctld-port').value = state.radio.config.wsPort || 4533;
    const noWS = document.getElementById('radio-no-webserial');
    if (noWS) noWS.style.display = !('serial' in navigator) ? 'block' : 'none';
    const rbtn = document.getElementById('btn-radio-connect');
    if (rbtn) {
      if (state.radio.connected) { rbtn.textContent = 'DISCONNECT'; rbtn.style.color = 'var(--green)'; }
      else { rbtn.textContent = 'CONNECT RADIO'; rbtn.style.color = ''; }
    }
    document.getElementById('settings-modal').classList.remove('hidden');
  });

  document.getElementById('btn-settings-close').addEventListener('click', () => {
    state.settings.minElevation = parseInt(document.getElementById('setting-min-elev').value) || 5;
    state.settings.updateInterval = parseInt(document.getElementById('setting-interval').value) || 1000;

    // Base map change
    const newBase = document.getElementById('setting-basemap').value;
    if (newBase !== state.settings.baseMap) {
      state.settings.baseMap = newBase;
      applyBaseMap(newBase);
    }

    // Overlay toggles
    ['radar', 'aurora', 'labels', 'nautical'].forEach(id => {
      const cb = document.getElementById('overlay-' + id);
      if (cb) toggleOverlay(id, cb.checked);
    });

    localStorage.setItem('sat_tracker_settings', JSON.stringify(state.settings));
    // Save radio settings
    state.radio.config.dopplerCorrection = document.getElementById('setting-radio-doppler').checked;
    state.radio.config.autoTune = document.getElementById('setting-radio-autotune').checked;
    state.radio.config.splitVfo = document.getElementById('setting-radio-split').checked;
    RadioController.saveConfig();
    state.nextPassCache = {};
    document.getElementById('settings-modal').classList.add('hidden');
  });

  document.getElementById('btn-refresh-tle').addEventListener('click', async () => {
    const btn = document.getElementById('btn-refresh-tle');
    btn.textContent = 'FETCHING...';
    try { await fetchTLEData(true); btn.textContent = 'QSL!'; state.lastTrackTime = 0; }
    catch (e) { btn.textContent = 'QRX FAIL'; }
    setTimeout(() => btn.textContent = 'Refresh TLE', 2000);
  });

  // Track button — auto-follow camera
  document.getElementById('btn-track').addEventListener('click', () => {
    state.trackingMode = !state.trackingMode;
    document.getElementById('btn-track').classList.toggle('active', state.trackingMode);
  });

  // Radio settings — brand dropdown show/hide
  document.getElementById('setting-radio-brand').addEventListener('change', () => {
    const brand = document.getElementById('setting-radio-brand').value;
    const modelRow = document.querySelector('.radio-model-row');
    const serialRow = document.querySelector('.radio-serial-row');
    const rigctldRow = document.querySelector('.radio-rigctld-row');
    modelRow.style.display = (brand !== 'none' && brand !== 'rigctld') ? 'flex' : 'none';
    serialRow.style.display = (brand !== 'none' && brand !== 'rigctld') ? 'flex' : 'none';
    rigctldRow.style.display = (brand === 'rigctld') ? 'flex' : 'none';
    const modelSelect = document.getElementById('setting-radio-model');
    modelSelect.innerHTML = '';
    const models = RADIO_MODELS[brand] || [];
    models.forEach(m => {
      const opt = document.createElement('option');
      opt.value = m.name; opt.textContent = m.name;
      if (m.baud) opt.dataset.baud = m.baud;
      if (m.civAddr) opt.dataset.civAddr = '0x' + m.civAddr.toString(16);
      modelSelect.appendChild(opt);
    });
    if (models.length > 0 && models[0].baud) document.getElementById('setting-radio-baud').value = models[0].baud;
    // Auto-select saved model
    if (state.radio.config.brand === brand && state.radio.config.model) {
      modelSelect.value = state.radio.config.model;
      const sel = modelSelect.options[modelSelect.selectedIndex];
      if (sel && sel.dataset.baud) document.getElementById('setting-radio-baud').value = sel.dataset.baud;
    }
  });

  // Radio model change — update baud rate
  document.getElementById('setting-radio-model').addEventListener('change', () => {
    const sel = document.getElementById('setting-radio-model');
    const opt = sel.options[sel.selectedIndex];
    if (opt && opt.dataset.baud) document.getElementById('setting-radio-baud').value = opt.dataset.baud;
    if (opt && opt.dataset.civAddr) state.radio.config.civAddress = parseInt(opt.dataset.civAddr);
  });

  // Radio connect/disconnect button
  document.getElementById('btn-radio-connect').addEventListener('click', async () => {
    const btn = document.getElementById('btn-radio-connect');
    if (state.radio.connected) {
      await RadioController.disconnect();
      btn.textContent = 'CONNECT RADIO'; btn.style.color = '';
      return;
    }
    const brand = document.getElementById('setting-radio-brand').value;
    if (brand === 'none') return;
    state.radio.config.brand = brand;
    state.radio.config.model = document.getElementById('setting-radio-model').value || '';
    state.radio.config.baudRate = parseInt(document.getElementById('setting-radio-baud').value) || 9600;
    state.radio.config.dopplerCorrection = document.getElementById('setting-radio-doppler').checked;
    state.radio.config.autoTune = document.getElementById('setting-radio-autotune').checked;
    state.radio.config.splitVfo = document.getElementById('setting-radio-split').checked;
    if (brand === 'rigctld') state.radio.config.wsPort = parseInt(document.getElementById('setting-rigctld-port').value) || 4533;
    if (brand === 'icom') {
      const addr = IcomProtocol.addresses[state.radio.config.model];
      if (addr) state.radio.config.civAddress = addr;
    }
    btn.textContent = 'CONNECTING...';
    try {
      await RadioController.connect();
      btn.textContent = 'DISCONNECT'; btn.style.color = 'var(--green)';
    } catch (e) {
      btn.textContent = 'CONNECT RADIO'; btn.style.color = '';
      const msg = document.getElementById('radio-status-msg');
      msg.textContent = e.message; msg.style.display = 'block'; msg.style.color = 'var(--red)';
      setTimeout(() => msg.style.display = 'none', 5000);
    }
  });

  // Floating layer panel
  document.getElementById('map-layers-toggle').addEventListener('click', () => {
    const btn = document.getElementById('map-layers-toggle');
    const drawer = document.getElementById('map-layers-drawer');
    btn.classList.toggle('open');
    drawer.classList.toggle('open');
  });

  // Base map buttons
  document.querySelectorAll('[data-basemap]').forEach(btn => {
    btn.addEventListener('click', () => {
      const mapId = btn.dataset.basemap;
      document.querySelectorAll('[data-basemap]').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      state.settings.baseMap = mapId;
      applyBaseMap(mapId);
      // Sync settings modal select
      const sel = document.getElementById('setting-basemap');
      if (sel) sel.value = mapId;
      localStorage.setItem('sat_tracker_settings', JSON.stringify(state.settings));
    });
  });

  // Overlay toggle buttons
  document.querySelectorAll('[data-overlay]').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = btn.dataset.overlay;
      const nowActive = btn.classList.toggle('active');
      btn.querySelector('.layer-dot').classList.toggle('active', nowActive);
      toggleOverlay(id, nowActive);
      // Sync settings modal checkboxes
      const cb = document.getElementById('overlay-' + id);
      if (cb) cb.checked = nowActive;
    });
  });

  // Mark the terminator button as active by default
  const termBtn = document.querySelector('[data-overlay="terminator"]');
  if (termBtn) { termBtn.classList.add('active'); termBtn.querySelector('.layer-dot').classList.add('active'); }

  // Keyboard shortcuts for layers
  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
    const keyMap = { g: 'gridsquares', m: 'muf', y: 'grayline', r: 'radar', a: 'aurora', l: 'labels', n: 'nautical', d: 'terminator' };
    const overlayId = keyMap[e.key.toLowerCase()];
    if (overlayId) {
      const btn = document.querySelector(`[data-overlay="${overlayId}"]`);
      if (btn) btn.click();
    }
  });

  document.querySelectorAll('.modal-overlay').forEach(o => o.addEventListener('click', e => { if (e.target === o) o.classList.add('hidden'); }));
  document.addEventListener('keydown', e => { if (e.key === 'Escape') { document.querySelectorAll('.modal-overlay').forEach(m => m.classList.add('hidden')); document.getElementById('map-layers-drawer').classList.remove('open'); document.getElementById('map-layers-toggle').classList.remove('open'); } });
}

// ============================================================
// INIT
// ============================================================
async function init() {
  try { const ss = JSON.parse(localStorage.getItem('sat_tracker_settings')); if (ss) Object.assign(state.settings, ss); } catch (e) {}
  RadioController.loadConfig();
  initMap();
  loadObserverLocation();
  setupEvents();

  try {
    await fetchTLEData();
    const n = Object.keys(state.satellites).length;
    document.getElementById('tle-status').textContent = `${n} BIRDS LOADED`;
  } catch (e) {
    document.getElementById('tle-status').textContent = 'TLE QRX FAIL';
    document.getElementById('loading-text').textContent = 'UNABLE TO ACQUIRE TLE DATA. CHECK NET.';
    return;
  }

  buildSatelliteList();

  // Auto-show ISS
  const iss = 25544;
  if (state.satellites[iss]) {
    state.visibleSatIds.add(iss);
    addSatMarker(iss);
    selectSat(iss);
    const cb = document.querySelector(`.sat-item[data-norad-id="${iss}"] input[type="checkbox"]`);
    if (cb) cb.checked = true;
  }

  document.getElementById('loading-overlay').classList.add('hidden');
  state.lastTrackTime = 0;
  animLoop();

  // First launch — auto-open Station Profile so user sets their location
  if (!state._hasExistingLocation) {
    setTimeout(() => {
      document.getElementById('input-lat').value = state.observer.lat;
      document.getElementById('input-lon').value = state.observer.lon;
      document.getElementById('input-alt').value = state.observer.alt || 0;
      updateDerivedDisplay(state.observer.lat, state.observer.lon, state.observer.countryCode);
      document.getElementById('location-modal').classList.remove('hidden');
    }, 1500);
  }
}

init();
</script>
</body>
</html>
